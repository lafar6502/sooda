<?xml version="1.0" encoding="windows-1250" ?>
<?xml-stylesheet type="text/xsl" href="style.xsl" ?>
<content lang="en" id="documentation">
    <p style="font-size: 12pt; color: red">
        This documentation is under construction. Many sections are missing. Please report any grammar, spelling or inacurracy issues to the <a href="http://www.sooda.org/mailinglist.html">mailing list</a>.
    </p>
    <table-of-contents />
    <section id="intro">
        <title>Introduction to Sooda</title>
        <section id="whatissooda">
            <title>What is Sooda?</title>
            <body>
                <p>
                    <b>Sooda</b> (Simple Object-Oriented Data Access) is an Object-To-Relational Mapping 
                    software for the <a href="http://msdn.microsoft.com/net">.NET</a> environment.
                    O/R Mapping Software enables you to express your business rules without using SQL at all.
                </p>
                <p>
                    Sooda is a code generator, which can generate entire Data Access Layer for your application.
                    Each class of the DAL typically corresponds to a database table,
                    its properties map to database columns and relationships map to object references and collections.
                </p>
            </body>
            <section id="features">
                <title>Features</title>
                <body>
                    <p>
                        Sooda supports the following features, which are explained in the following sections:
                    </p>
                    <ul>
                        <li>mapping <a href="#mappingtablestoclasses">one</a> or <a href="#mappingmultipletablestoclasses">more tables</a> to a class</li>
                        <li><a href="#mappingonetomany">one-to-many</a> and <a href="#mappingmanytomany">many-to-many</a> relationships</li>
                        <li><a href="#pathexpressions">path expressions</a>, both in code and the in query language</li>
                        <li><a href="#primarykeys">identity management through L1 caching</a></li>
                        <li><a href="#inheritance">inheritance</a> (two models: table-per-hierarchy (TPH) and table-per-subclass (TPS))</li>
                        <li>strongly-typed, database-based <a href="#schemaconst">enumerations</a></li>
                        <li><a href="#lazyloading">lazy loading</a></li>
                        <li><a href="#transactions">differential serialization and deserialization</a> of uncommitted changes (enables long-running transactions)</li>
                        <li>strongly-typed <a href="#querylanguage">query language</a> (based on C# operator overloading)</li>
                        <li>text-based <a href="#querylanguage">query language</a> - SOQL</li>
                        <li><a href="#mappingmultipletablestoclasses">vertical partitioning</a> of data (load-on-demand for large columns)</li>
                        <li><a href="#caching">cross-transaction (level-2) caching</a></li>
                    </ul>
                </body>
            </section>
            <section id="supportedplatforms">
                <title>Supported Platforms</title>
                <body>
                    <p>
                        Sooda supports .NET Framework 1.1 and 2.0 and Mono profile 1.0 and 2.0. .NET Framework 1.0 is NOT supported.
                    </p>
                    <p>
                        The following development tools/build environments are supported:
                    </p>
                    <ul>
                        <li>Visual Studio 2005 (.NET Framework 2.0)</li>
                        <li>Visual Studio 2003 (.NET Framework 1.1)</li>
                        <li>NAnt 0.85</li>
                    </ul>
                </body>
            </section>
            <section id="supportedrdbms">
                <title>Supported Relational Databases</title>
                <body>
                    <p>
                        The following RDBMSes are supported:
                    </p>
                    <ul>
                        <li>Microsoft SQL Server 2000, 2005 (including MSDE and SQL Server Express Edition)</li>
                        <li>MySQL v4.x</li>
                        <li>PostgreSQL v8.x</li>
                        <li>Oracle 8i, 9i, 10g</li>
                    </ul>
                    <p>
                        Sooda has been used in production systems for at least 3 years and things are generally working smooth.
                        Some graphical and command line tools to support the development are available, but they are generally
                        newer and still require some work.
                    </p>
                </body>
            </section>
            <section id="supportedlanguages">
                <title>Supported Languages</title>
                <body>
                    <p>
                        Sooda supports code generation using CodeDOM technology. In theory any language should be supported,
                        but some languages have problems with their CodeDOM providers or their compilers are buggy.
                        The following languages have been tested:
                    </p>
                    <ul>
                        <li><a href="http://msdn.microsoft.com/csharp/">C#</a> - fully supported, code compiles cleanly, supports <a href="#soqltypedqueries">Typed Queries</a>.</li>
                        <li><a href="http://msdn.microsoft.com/vbasic/">VB.NET</a> - fully supported, some warnings may be raised during compilation of the generated code, but they can be ignored.</li>
                        <li><a href="http://boo.codehaus.org/">Boo</a>> - works - EXPERIMENTAL</li>
                        <li><a href="http://msdn.microsoft.com/vjsharp/">VJ#</a> - works - EXPERIMENTAL</li>
                        <li><a href="http://www.nemerle.org/">Nemerle</a> - not supported - fails compilation</li>
                        <li><a href="http://msdn.microsoft.com/jscript/">JScript.NET</a> - not supported - compilation fails with internal error</li>
                        <li><a href="http://www.codeplex.com/Wiki/View.aspx?ProjectName=IronPython">IronPython</a> - code generation works, needs further investigation</li>
                    </ul>
                </body>
            </section>
        </section>
        <section id="basicconcepts">
            <title>Basic Concepts</title>
            <body>
                This section explains basic O/R mapping concepts and provides general overview of Sooda features.
            </body>

            <section id="mappingtablestoclasses">
                <title>Mapping Classes to Tables</title>
                <body>
                    <p>
                        Most applications written in high-level languages use the object-oriented 
                        approach and often they need to store data in relational databases.

                        Working with objects, we use method calls, properties
                        events, collections, inheritance, polymorphism, and so on, while working with relational data 
                        requires us to think in terms of SELECT,INSERT,UPDATE and DELETE SQL operations
                        on rectangular tables.
                    </p>
                    <p>
                        Obviously the two models (object-oriented and relational) are not 
                        compatible. Sooda lets you bridge the gap by providing an object-oriented interface to the database so that
                        you can write code in your favourite high-level language without using SQL at all.
                    </p>
                    <p>
                        Let's see how objects can be stored in a database. Assuming we have a simple class named Employee.
                    </p>
                    <img src="doc0.gif" alt="Employee Class" />
                    <p>
                        Objects of this class can be persisted when we follow the rules of so called "natural mapping", where:
                    </p>

                    <ul>
                        <li>each object is stored in a single row of a single table whose name matches the name of the class</li>
                        <li>each property is stored in a single column, whose name matches the name of the property/field</li>
                        <li>the type of the column corresponds to the type of the property</li>
                    </ul>

                    <p>
                        Applying these "natural mapping" rules to the Employee class, we get the following table:
                    </p>
                    <img src="doc1.gif" alt="Employee Table" />
                    <p>
                        Natural mapping as described above is not always possible/desirable and therefore we need a <a href="#schema">mapping schema</a> to
                        fully describe the mapping for tables/columns/datatypes and more. We can for example:
                        </p>
                    <ul>
                        <li>override database table name (for example TblEmployee instead of Employee). 
                            There are some reserved SQL keywords which cannot be used as table names (<code>SELECT, FROM, WHERE, GROUP</code>)</li>
                        <li>define names of database columns (for example hire_date instead of HireDate). Some databases 
                            impose limitations on the
                            maximum column names so you might want to make them shorter.</li>
                        <li>use other datatypes (such as a column of type "integer" instead of "bit" to store the 
                            value of the "Active" property with "true" and "false" mapped to "1" and "0" respectively)</li>
                        <li>objects may need to be persisted in <a href="#mappingmultipletablestoclasses">more than one table</a></li>
                    </ul>
                </body>
            </section>
            <section id="primarykeys">
                <title>Primary Keys and Object Identity</title>
                <body>
                    <p>
                        Entities in the databases are identified by their primary keys. In object-oriented
                        languages we refer to objects by their references. The references are
                        valid only for a single execution of the program and cannot be stored in a database directly.
                        O/R mapper needs to convert between primary key values and object references 
                        when loading and storing data.
                    </p>
                    <p>
                        Each object in Sooda knows about the primary key that represents it in the database.
                        Transaction-level object cache (L1 cache) is used to map primary keys to objects.
                        This two-way mapping lets Sooda provide <a href="#objectidentity">reference identity</a> for objects
                        it manages.
                    </p>
                    <p>
                        When creating a new object in memory, the primary key needs to be known in advance (before
                        the object is actually stored in the database). Because of this, we cannot use identity columns in
                        databases to provide primary keys, other mechanism to generate primary keys is necessary.
                    </p>
                    <p>
                        Sooda provides <a href="#keygeneration">key generators</a> which may be used for this purpose.
                        The default one uses a special table in the database to manage batched key allocation. Alternatively, for primary
                        keys which are GUIDs, you can use the standard Guid.NewGuid() generation method.
                    </p>
                </body>
            </section>
            <section id="mappingonetomany">
                <title>One-To-Many Relationships</title>
                <body>
                    One-to-many relationalships are typically represented as collections of objects related
                    to some particular object (only one). Typical examples are:
                    <ul>
                        <li>customer has a collection of orders (each order has exactly one customer)</li>
                        <li>group has members (each member belongs to exactly one group)</li>
                        <li>mother has children (each child has exactly one mother)</li>
                    </ul>
                    In databases we usually represent relationships as foreign key columns stored in the
                    "child" objects, so to represent the customer-to-orders relatioship we have a foreign
                    key column (perhaps named "customer") stored in the "Order" table. The value stored
                    in this column must match the primary key value of the Customer. 
                    
                    The following piece of SQL code demonstrates this for a simple Customer to Order relationship:

                    <code lang="SQL">
                        <![CDATA[
create table Customer
(
    ID int primary key not null,
    Name varchar(64),
    Address1 varchar(64),
    Address2 varchar(64)
);

create table Order
(
    ID int primary key not null,
    -- more columns here
    CustomerID int not null references Customer(ID)
);
                        ]]>
                    </code>

                    <img src="doc2.gif" alt="One-To-Many relationship between Customer and Order" />
                    <p>
                    </p>

                    <p>
                        Sooda makes the task of managing foreign key relationships rather simple by providing
                        a dual view of the relationship: reference from a "child" to its "parent" and a collection
                        of "children" that's a member of the "parent". You only need to specify which property in the
                        "child" object is a reference to the "parent" object. Code generated by Sooda includes the following APIs:
                    </p>
                    <code lang="C#">
class Customer
{
    int ID { get; set; }
    string Name { get; set; }
    ...
    OrderList Orders { get; }
}

class Order
{
    int ID { get; set; }
    Customer Customer { get; set; }
}
                    </code>
                    <p>
                        The OrderList is functionally equivalent to IList&lt;Order&gt; with some filtering
                        and sorting methods <a href="#generatedlistwrappers">included for convenience</a>. Customer is
                        a reference to the Customer class. Sooda lets you write:
                    </p>
                    <code lang="C#">
Customer c;

// create new order
Order o = new Order()
c.Orders.Add(o);
// this is equivalent to the above
o.Customer = c; 
c.Orders.Remove(o);
// get order count
c.Orders.Count; 
// check it the orders contains the specified one
c.Orders.Contains(o); 
// return a sorted collection
c.Orders.OrderBy(sortExpression); 

                    </code>
                    <p>
                       Convenience methods of Sooda collections are described <sectionlink id="generatedlistwrappers" />.
                    </p>
                </body>
            </section>
            <section id="mappingmanytomany">
                <title>Many-To-Many Relationships</title>
                <body>
                    <p>
                        Many-to-many relationalships are used in many situations, such as these:
                    </p>
                    <ul>
                        <li>person-to-permission (each person has many permissions, each permission is held by many persons)</li>
                        <li>lecture-to-student (each student attends many lectures, each lecture is attended by many students)</li>
                        <li>and so on</li>
                    </ul>
                    <p>
                        Database representation of many-to-many relationships requires a separate table that will
                        hold pairs of primary keys that are in relationship, such as the Employee2Permission table in the following
                        figure:
                    </p>
                    <img src="doc3.gif" alt="Many-To-Many relationship between Employee and Permission using Employee2Permission" />
                    <p>
                        The SQL used to create this database is:
                    </p>
                    <code lang="SQL">
                        <![CDATA[
create table Employee
(
    ID int primary key not null,
    Name varchar(64),
    Address1 varchar(64),
    Address2 varchar(64)
);

create table Permission
(
    ID int primary key not null,
    PermissionName varchar(64),
);

create table Employee2Permission
(
    EmployeeID int not null references Employee(ID),
    PermissionID int not null references Permission(ID)
)

alter table Employee2Permission add primary key (EmployeeID,PermissionID);
                        ]]>
                    </code>
                    <p>
                        Sooda generates a pair of collection which provide access to objects in the relationship. In this example, we have:
                    </p>
                    <code lang="C#">
class Employee
{
    ...
    PermissionList Permissions { get; }
}

class Permission
{
    ...
    EmployeeList Employees { get; }
}
                    </code>
                    <p>
                        These collections support the same set of operations as one-to-many collections, namely Add(), Remove(), 
                        Contains(), Count and others. The collections are synchronized, no matter which object you
                        use to modify the relationships, the result is the same. In this example you could:
                    </p>
                    <ul>
                        <li>add a Permission to a collection of permissions held by Employee</li>
                        <li>add an Employee to a collection of employeees which hold the permission</li>
                    </ul>
                    <code lang="C#">
using (SoodaTransaction t = new SoodaTransaction())
{
    Employee emp = ...;
    Permission perm = ...;

    // the following two lines are equivalent
    emp.Permissions.Add(perm); // add permission to the emp's permission collection
    perm.Employees.Add(emp); // add employee to perm's employees collection

    if (emp.Permissions.Contains(perm))
    {
        Console.WriteLine("Employee is authorized.");
    }

    // this tests essentially the same thing
    if (perm.Employees.Contains(emp))
    {
        Console.WriteLine("Employee is authorized.");
    }    
}
</code>
                </body>
            </section>
            <section id="lazyloading">
                <title>Lazy Loading</title>
                <body>
                    <p>
                        Often you need to operate on an object but you don't need access to its properties.
                        It would be very inefficient to load full record from a database each time
                        a reference to it is needed. For example you don't need to know employee's name 
                        just to check if he is in relationship with some other objects.
                    </p>
                    <p>
                        Sooda supports lazy loading by maintaining a data structure that holds object data. It 
                        loads the data and initializes the data structures on as-needed basis, which means objects don't allocate 
                        memory for their data values until the properties are accessed.
                    </p>
                    <p>
                        Each object managed by Sooda can be in one of the four states:
                    </p>
                    <ul>
                        <li><b>Data Not Loaded</b> - no properties have been accessed</li>
                        <li><b>Data Loaded</b> - some properties have been read</li>
                        <li><b>Data Not Loaded - Modified</b> - some properties have been written to, but not read from</li>
                        <li><b>Data Loaded - Modified</b> - some properties have been written to, and some have been read from</li>
                    </ul>
                    <img src="doc4.png" alt="Possible lazy loading states of an object" />
                    <p>
                        Each time a property is read in <b>Data Not Loaded</b> or <b>Data Not Loaded-Modified</b> state
                        Sooda needs to access the database to load the data. If a property is only written to, there's no need
                        to even load the data from the database.
                    </p>
                    <p>Lazy loading is described <sectionlink id="loadingobjects" />.</p>
                </body>
            </section>
            <section id="pathexpressions">
                <title>Path expressions and managing referenced objects</title>
                <body>
                    <p>
                        Objects in memory may form graphs: they may include properties which are
                        references to other objects and these objects may have references to other objects 
                        and so on.
                    </p>
                    <p>
                        Sooda supports path expressions both in code and in <a href="#querylanguage">query language</a>
                        which let you access related objects' properties easily. 
                        For example to access the last name of the manager of a person's organization unit:
                    </p>
                    <code lang="C#">
                        // display the last name of person's org unit
                        Console.WriteLine(person.OrganizationUnit.Manager.LastName);
                    </code>
                    <p>
                        You can access collections in the same manner:
                    </p>
                    <code lang="C#">
                        // display the number of org unit members
                        Console.WriteLine(person.OrganizationUnit.Members.Count);
                    </code>
                    <p>
                        Object references are fully lazy-loaded and managed by <a href="#primarykeys">transaction L1 cache</a>
                        so that the number of database accesses is reduced.
                    </p>
                </body>
            </section>
            <section id="mappingmultipletablestoclasses">
                <title>Mapping Multiple Tables to a Single Class</title>
                <body>
                    <p>
                        A class can be mapped to more than one table in the database or it can be split into many logical "tables" which
                        are actually mapped to the same physical table. We may want to do it for many reasons:
                    </p>
                    <ul>
                        <li>database engine limitations - some databases have maximum row size limit, and you may not be able to store
                            long texts in a single table because of this limit. Splitting table in two and performing joins by primary key
                            may be the only option</li>
                        <li>performance - imagine you have some large field which you access infrequently (such as a person's picture). 
                            Loading the field from the database would not be efficient because it would consume time and memory.
                            Lazy loading mechanism works on a table level which means that it loads the entire row from a table each
                            time a single column is accessed. Putting the large column in a separate table helps remediate this issue.
                        </li>
                    </ul>
                    <p>This is the most typical situation where some columns may be placed in a separate table for performance:</p>
                    <img src="doc5.gif" alt="Large columns moved to a separate table" />
                    <p>If the data row size is not a problem, we may still want to do the logical partitioning of data while
                        keeping them in a single table. We only need to tell Sooda to keep some fields together by grouping them in
                        a logical Table.</p>
                    <p>
                        The following example shows the Employee table which contains two large columns which we want to load separately: 
                        Picture which is an image and VoiceSample which is a blob. Possible partitions of this table are marked with
                        separate colors. Note that the primary key column is not marked because it is always present in memory and
                        doesn't need to be loaded at all.
                    </p>
                    <img src="doc6.gif" alt="Grouping large columns for lazy loading"/>
                    <p>
                        Sooda makes it possible to create a class based on up to 32 physical or logical tables. The only thing they
                        need to have in common is their primary key. This feaure is used in inheritance, which is described <sectionlink id="inheritance" />.
                    </p>
                </body>
            </section>
            <section id="inheritance">
                <title>Inheritance</title>
                <body>
                    <p>
                        Inheritance ("is-a" relationship) is an object-oriented programming concept which is not present in
                        relational databases. One of the most important features of inheritance is polymorphism (ability to
                        act on objects through their base classes or interfaces without knowing their exact type).
                    </p>
                    <p>
                        Inheriting classes may introduce additional fields (properties) and we need a way to store them in a database.
                        There are 3 methods of storing inheritance hierarchy in database:
                    </p>
                    <ul>
                        <li><b>TPT</b> or <b>TPS</b>- table per type (or table per subclass) - each class that adds member fields stores them in a separate table</li>
                        <li><b>TPH</b> - table per hierarchy - fields for all classes in the inheritance hierarchy are stored in a single table</li>
                        <li><b>TPC</b> - table per concrete type - each concrete type (non-abstract class) is kept in its own table.</li>
                    </ul>
                    <p>
                        Assuming you have a simple hierarchy of 4 classes:
                    </p>
                    <img src="doc8.gif" alt="Hierarchy of classes" />
                    <p>
                        The TPT representation of this hierarchy looks like this (note that each subclass is stored in its own table,
                        and only the fields added in that subclass are kept there, the other fields are accessible through primary key join):
                    </p>
                    <img src="doc7.gif" alt="TPT(TPS) representation" />
                    <p>
                        TPH model (note that fields from all classes are gathered in a single table and each field from a non-root class
                        is nullable):
                    </p>
                    <img src="doc9.gif" alt="TPH representation" />
                    <p>
                        Or a TPC model (fields from the base class are repeated in all tables):
                    </p>
                    <img src="doc10.gif" alt="TPC representation" />
                    <p>
                        Supporting polymorphism in O/R mapping requires the engine to be able to create instances
                        of the proper subclass on load. This is required because when you load an object from 
                        the database you may get an instance of a subclass.
                        Object refererences (stored as foreign keys) are also polymorphic (you only store the key value, not the 
                        concrete type). We need a way to be able to quickly determine the concrete class that will
                        represent the object from the database.
                    </p>
                    <p>
                        TPT and TPH storage models require a special column (called discriminator column) to select between subclasses. 
                        This column needs to provide a unique mapping between the concrete class and an integer value
                        (for example 1-QuestionWorkItem, 2-AnalysisWorkItem, 3-BugWorkItem). 
                        Each time an object of a particular class is persisted, a value corresponding to its class is stored in
                        this column and on load this value is used to recreate object of the proper class.
                        TPC model doesn't need this column but makes it more difficult to access objects in a polymorphic manner,
                        because you need to perform a UNION select or make multiple queries in order to fetch all objects.
                    </p>
                    <p>
                        Polymorphic access enables you to write:
                    </p>
                    <code lang="C#">
<![CDATA[
WorkItem wi = WorkItem.Load(3);
if (wi is QuestionWorkItem)
{
    QuestionWorkItem qwi = (QuestionWorkItem)wi;

    Console.WriteLine("question: {0}", qwi.Question);
}

// display concrete types of all work items
foreach (WorkItem wi in WorkItem.GetList(true))
{
    Console.WriteLine("wi: {0}", wi.GetType().FullName);
}

]]>
                    </code>
                    <p>
                        Sooda supports TPT and TPH, but <b>doesn't support TPC model</b> because it's less efficient
                        than the other two and requires complex SQL queries to be generated.
                    </p>
                    <p>
                        Sooda extends the concept of "tables" on which each class is based to mean not only physical tables
                        but also vertical table partitions. This way you can create a mixture of TPT and TPH in your program.
                        For example you can store the hierarchy in TWO tables instead of one. You can also
                        store most commonly used subclasses in a single table but move rarely used or "heavy" data (such as blobs) 
                        to separate physical tables.
                    </p>
                </body>
            </section>
            <section id="transactions">
                <title>Transactions</title>
                <body>
                    <p>
                        Each database-backed object in Sooda is associated with a transaction represented by 
                        an instance of SoodaTransaction class. Transactions provide database connection management,
                        identity management (ensuring reference-level object identity as mentioned <sectionlink id="primarykeys" />).
                    </p>
                    <p>
                        In order to support identity management, transactions implement an L1 cache of all alive objects. You
                        can retrieve objects by their references as by pairs of (class name,primary key value).
                    </p>
                    <p>
                        No object can live outside the transaction and object state is not defined after the transaction
                        has been closed. Keeping a transaction open for a longer period of time is not recommended because it consumes
                        unmanaged resources, such as a database connections.
                    </p>
                    <p>
                        Transactions need to be closed when they are no longer needed and if you fail ensure that, otherwise
                        you may get all sorts of unmanaged resource leaks. Typical usage pattern for a Sooda transaction 
                        that ensures the transaction is properly closed is presented below. It makes use of the
                        IDisposable pattern and the C# using() statement:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            // perform operations on Sooda objects here
                            t.Commit();
                        }
                    </code>
                    <p>
                        In order to support long-running transactions, Sooda supports a differential
                        serialization mechanism, which lets you persist uncommitted changes made within transaction to an XML document, 
                        and deserialize them later, perhaps in a different process or a different machine.
                    </p>
                </body>
            </section>
            <section id="querylanguage">
                <title>Query Language</title>
                <body>
                    <p>
                        We need a way to retrieve objects from the database based on the specified criteria. SQL is inappropriate for
                        this, because it doesn't make use of concepts such as:
                    </p>
                    <ul>
                        <li>path expressions (explicit joins are necessary)</li>
                        <li>collections (both one-to-many and many-to-many)</li>
                        <li>inheritance</li>
                        <li>enumerations</li>
                    </ul>
                    <p>
                        Sooda supports two variants of its object-oriented query language:
                    </p>
                    <ul>
                        <li>text-based query language called <a href="#soqltext">SOQL</a></li>
                        <li>a <a href="#soqltypedqueries">strongly-typed</a>, in-code variant of SOQL implemented using C# operator overloading</li>
                    </ul>
                    <p>
                        Both of them let you use path expressions and collections to write join-free powerful
                        object-oriented queries. This is described <sectionlink id="soql" />.
                    </p>
                </body>
            </section>
            <section id="caching">
                <title>Cross-transaction (Level 2) Caching</title>
                <body>
                    <p>
                        Frequent use of single rows from the database (which is common for all O/R mapping products) can be
                        expensive. The cost of an SQL server roundtrip can be quite high. Sooda implements in-memory caching of objects
                        retrieved from the SQL database (both single rows and collections) so that the speed of processing is improved.
                    </p>
                    <p>
                        The <a href="#cachingapi">Caching API section</a> explains things in detail.
                    </p>
                </body>
            </section>
        </section>
    </section>
    <section id="gettingstarted">
        <title>Getting Started</title>
        <body>
            <p>
                In order to use Sooda in your project you need to have a working database. We'll be using Microsoft
                SQL Server and the Northwind database.
            </p> 
            <todo />
        </body>
    </section>
    <section id="schema">
        <title>O/R Mapping Schema</title>
        <body>
            <p>
                O/R Mapping Schema defines the mapping between CLI classes and database tables. 
            </p>
            <p>
                The schema is contained in an XML file that is the input to <a href="#soodastubgen">SoodaStubGen utility</a> which
                generates class stubs. You can write the XML file by hand or you can use a tool, such as 
                <a href="#soodaschematool">SoodaSchemaTool</a> to generate it for you by reverse-engineering the database.
                Note that it's not possible to generate the mapping schema in a fully automated manner. There are 
                things that simply cannot be retrieved from the database (such as inheritance relationships, named constants, many-to-many
                relationship names), anyway the tools can give you a good approximation of the actual schema.
            </p>
            <p>
                The root of the XML document is the <x><schema /></x> element with the appropriate XML namespace (<code>http://www.sooda.org/schemas/SoodaSchema.xsd</code>).
                Child elements of the <x><schema /></x> define classes, relations and so on, as described below.
            </p>
            <code lang="XML">
                <![CDATA[
                <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                    <datasource />

                    <class />
                    <class />
                    <class />
                    <class />

                    <relation />
                    <relation />
                </schema>
                ]]>
            </code>
        </body>
        <section id="schemadatasources">
            <title>Data Sources - <x><datasource /></x></title>
            <body>
                <p>
                    Data Sources are defined with the <x><datasource /></x> element. A data source represents a 
                    connection to the database (or other store) where entities are stored. Each data source has a name and type. 
                    Sooda currently supports only <a href="#sqldatasource">Sql Data Source</a>, but
                    it is (theoretically) possible to add more data source types. Unless specified otherwise, the 
                    default data source for a class or relation is "<code>default</code>", which you need to have defined.
                </p>
                <p>
                    While Sooda supports no other data source types, the declaration that should be present at the beginning of each
                    mapping schema is:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <datasource name="default" type="Sooda.Sql.SqlDataSource" />
                    </schema>
                    ]]>
                </code>
                <p>
                    You can define additional SQL-based data sources for example to connect to multiple databases at once. Sooda
                    will keep a single connection to each data source, but won't create one until you use an object that's based on
                    this data source.
                </p>
            </body>
        </section>
        <section id="schemaclasses">
            <title>Classes - <x><class /></x></title>
            <body>
                <p>
                    Classes are defined using <x><class /></x> elements. Each class is based on 
                    one or more tables, each represented by a <x><table /></x> element. 
                    The following table lists available
                    attributes of the <x><class /></x> element (bold ones are required).
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Class name - used by <a href="#soodastubgen">SoodaStubGen</a> to generate 
                                    the class skeleton, stub and related classes (factory, list wrapper, typed queries and so on).
                                    Details about the generated code can be found <sectionlink id="generatedcode" />.
                                </td>
                            </tr>
                            <tr>
                                <td>cardinality</td>
                                <td>ClassCardinality</td>
                                <td>Specifies the approximate number of instances of this class (number of rows in a table).
                                    Possible values are:
                                    <ul>
                                        <li><b>Small</b> - up to 20-30</li>
                                        <li><b>Medium</b> - more than Small, up to 200-300</li>
                                        <li><b>Large</b> - more than a few hundred</li>
                                    </ul>
                                    The default value is <b>Medium</b>. You may want to specify other values as a hint to the cache optimizer.
                                    Other than that, this value is not used.
                                </td>
                            </tr>
                            <tr>
                                <td>datasource</td>
                                <td>string</td>
                                <td>Specifies the name of the <a href="#datasources">data source</a> for this class. The default name is "default".</td>
                            </tr>
                            <tr>
                                <td>extBaseClassName</td>
                                <td>string</td>
                                <td>Specifies the name of the base class that this class should inherit from. By default each class N inherits 
                                    from N_Stub which in turn inherits from SoodaObject. Set this option to make the stub class inherit from some other class.
                                    Note that the class must ultimately inherit from SoodaObject (either directly or indirectly).
                                </td>
                            </tr>
                            <tr>
                                <td>label</td>
                                <td>string</td>
                                <td>Name of the property that provides the human readable "identity" of the object. For example the 
                                    "Person" class might have a label of "Name" or "Email", the "Location" class
                                    might have a label of "Address".
                                    The label is used to generate the default implementation of ToString() for object.
                                </td>
                            </tr>
                            <tr>
                                <td>keygen</td>
                                <td>string</td>
                                <td>Specifies a method that will be used to generate primary keys for newly created objects. 
                                    The following options are supported:
                                    <ul>
                                        <li><b>guid</b> - generate GUID keys in-memory by calling Guid.NewGuid()</li>
                                        <li><b>integer</b> - pregenerates integer keys in the database by storing them in the KeyGen table. This is the default.</li>
                                        <li><b>long</b> - pregenerates long (64-bit) keys in the database by storing them in the KeyGen table.</li>
                                    </ul>
                                    Alternatively you can provide a name of the class that implements IPrimaryKeyGenerator that will provide primary keys. 
                                    This class call a webservice or use other means necessary to generate keys in a coordinated manner, guaranteeing that
                                    no two sessions will ever get the same primary key.
                                </td>
                            </tr>
                            <tr>
                                <td>inheritFrom</td>
                                <td>string</td>
                                <td>
                                    Specifies the base class. This parameter is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>defaultPrecommitValue</td>
                                <td>depends on primary key type</td>
                                <td>
                                    Specifies the default precommit value for this class. This is the value that will be INSERT'ed into
                                    the database for each not-nullable column that doesn't have a value specified. You can override it on the
                                    <a href="#schemafield"><x><field /></x></a> level.
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorValue</td>
                                <td>depends on primary key type</td>
                                <td>
                                    Specifies the value of the subclass selector field that determines this object type. This parameter 
                                    is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorField</td>
                                <td>string</td>
                                <td>
                                    Specifies the name of the subclass selector field that determines this object type. This parameter 
                                    is explained in the <a href="#schemainheritance">inheritance section</a>.
                                </td>
                            </tr>
                            <tr>
                                <td>cached</td>
                                <td>bool</td>
                                <td>
                                    Caching hint. The actual interpretation depends on the <a href="#caching">caching policy</a> that's in effect.
                                </td>
                            </tr>
                            <tr>
                                <td>cacheCollections</td>
                                <td>bool</td>
                                <td>
                                    Collection caching hint. The actual interpretation depends on the <a href="caching">caching policy</a> that's in effect.
                                </td>
                            </tr>
                            <tr>
                                <td>disableTypeCache</td>
                                <td>bool</td>
                                <td>Disable type cache for this type. This parameter is described in the <a href="#schemainheritance">inheritance section</a></td>
                            </tr>
                            <tr>
                                <td>triggers</td>
                                <td>bool</td>
                                <td>Determines whether <a href="#triggers">triggers</a> should be generated for this class.</td>
                            </tr>
                            <tr>
                                <td>readOnly</td>
                                <td>boolean</td>
                                <td>
                                    Generates read-only class. No property setters are generated in such case 
                                    and some scenarios are optimized.
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
        </section>
        <section id="schematable">
            <title>Tables - <x><table /></x></title>
            <body>
                <p>
                    <x><table /></x> elements are used to define the mapping from database tables to classes and relations as described
                    <sectionlink id="mappingtablestoclasses" />. Each class is based on at least one <x><table /></x> element. Each table consists of <x><field /></x> 
                    elements which represent columns in a database and properties in C#/VB. Each table must have at least one
                    field which is marked as the primary key. Compound primary keys (formed by multiple fields with primaryKey attribute)
                    are supported, but tables with zero primary keys are not allowed.
                </p>
                <p>
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="className">
                        <table name="tableName1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                        <table name="tableName2">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                        <table name="tableName3">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    The typical definition of a class that's based on a single table looks like this:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Person">
                        <table name="Person">
                            <field name="Id" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Location" type="String" size="40" />
                            <field name="PictureBlob" type="Image" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    <x><field /></x> elements are discussed in depth <sectionlink id="schemafield" />.
                </p>
                <p>
                    Objects may need to be <a href="#mappingmultipletablestoclasses">stored in multiple tables</a> for efficiency reasons. 
                    In the following example we have two tables - one has employee ID, Name, Salary, HireDate and Active flag, 
                    the other stors his/her Picture (potentially very large piece of binary data that encodes the person's photo). 
                    By storing the picture in a separate table we can avoid reading from it until the data is actually needed.
                </p>
                <img src="doc5.gif" alt="Large columns moved to a separate table" />
                <p>
                    This is represented by the following fragment of schema:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                        <table name="EmployeePicture">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Picture" type="Image" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    Each <x><table /></x> is a unit for the load operation, which means whenever you access
                    one field from a table, the entire table row gets loaded and is cached for further accesses. This is easy way 
                    to implement fine-grained <a href="#lazyloading">lazy loading</a> by splitting your fields in groups that are always accessed together.
                </p>
                <p>
                    It is possible to have two <x><table /></x> elements that are bound to the same physical database table. You only need to repeat
                    the primary key field in each <x><table /></x> element. This allows for column-based lazy loading without the need to create
                    additional database tables. For example, the followin Employee class uses mentioned partitioning feature
                    to avoid loading Picture and VoiceSample with other columns.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Employee">
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                            <field name="Salary" type="Decimal" />
                            <field name="HireDate" type="DateTime" />
                            <field name="Active" type="BooleanAsInteger" />
                        </table>
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Picture" type="Image" />
                        </table>
                        <table name="Employee">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="VoiceSample" type="Blob" />
                        </table>
                    </class>
                    ]]>
                </code>
                <p>
                    The table definition looks like this (different lazy loading groups are marked with different colors):
                </p>
                <img src="doc11.gif" alt="Lazy loading groups" />
                <p>
                    Example: We have 4 objects: Adam (Person, with primary key 1), Eva (with primary key 2), 
                    Mary (with primary key 3), John (with primary key 4). Let's assume they are represented by the 
                    corresponding variable names and see how lazy loading works as we access their properties and
                    display them.
                </p>

                <code lang="C#">
                    <![CDATA[
                    Person adam;
                    Person eva;
                    Person mary;
                    Person john;

                    // 1. read Adam's name - this causes a SELECT on a database.
                    Console.WriteLine(adam.Name); 

                    // 2. read Adam's address - database access is not needed because the appropriate row
                    // from the database has been loaded in step #1
                    Console.WriteLine(adam.Location); 

                    // 3. access the picture of Adam - we need to access a database
                    Console.WriteLine(adam.Picture); 

                    // 4. we load PictureBlob for Eva (note that neiter Name nor Location is loaded yet)
                    Console.WriteLine(eva.Picture); 

                    // 5. access the Name of Eva - we load it along with her Location
                    Console.WriteLine(eva.Name); 

                    // 6. location already loaded in step #5 - no database read here
                    Console.WriteLine(eva.Location); 

                    // 7. read Adam's name - no database access - already loaded in step #1
                    Console.WriteLine(adam.Name); 

                    // 8. read Adam's picture - no database access - already loaded #3
                    Console.WriteLine(adam.Picture); 

                    // 9. read Adam's voice sample - causes a select on a database
                    Console.WriteLine(adam.VoiceSample.Length); 
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemafield">
            <title>Fields - <x><field /></x></title>
            <body>
                <p>
                    <x><field /></x> elements define the mapping between database columns and object properties or fields in relation table.
                    Each field represents a single column in the database.
                </p>

                <p>
                    Usage in a class definition:
                </p>

                <code lang="XML">
                    <![CDATA[
                    <class name="class1">
                        <table name="table1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" />
                            <field name="f3" type="t3" />
                            <field name="f4" type="t4" />
                        </table>
                    </class>
                    ]]>
                </code>

                <p>
                    Usage in many-to-many relation definition:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <relation name="class1">
                        <table name="table1">
                            <field name="f1" type="t1" primaryKey="true" />
                            <field name="f2" type="t2" primaryKey="true" />
                        </table>
                    </relation>
                    ]]>
                </code>

                <p>
                    The following attributes are available on the <x><field /></x> element. Attributes marked with bold are required:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Field name - used by <a href="#soodastubgen">SoodaStubGen</a> to generate 
                                    the C#/VB.NET property 
                                </td>
                            </tr>
                            <tr>
                                <td><b>type</b></td>
                                <td>FieldDataType</td>
                                <td>Data type. See the <a href="#schemadatatypes">supported data types</a> for more information.</td>
                            </tr>
                            <tr>
                                <td>dbcolumn</td>
                                <td>string</td>
                                <td>Name of the database column. If it is not specified, Sooda assumes this is the same
                                    as 'name'</td>
                            </tr>
                            <tr>
                                <td>size</td>
                                <td>integer</td>
                                <td>Data type size.</td>
                            </tr>
                            <tr>
                                <td>precision</td>
                                <td>integer</td>
                                <td>Data type precision.</td>
                            </tr>
                            <tr>
                                <td>references</td>
                                <td>string</td>
                                <td>Name of the class that this field references. The referenced class must have a single-field (i.e. not
                                    compound) primary key. It's not possible to automatically generate references to classes 
                                    with compound primary keys, but it is possible to do it in code.</td>
                            </tr>
                            <tr>
                                <td>onDelete</td>
                                <td>DeleteAction</td>
                                <td>The action to be taken when the referenced object is deleted (valid when <b>references</b> is not empty).
                                    <ul>
                                        <li><b>Nothing</b> - do nothing, the programmer will take care of updating/deleting the 
                                            appropriate object references. Failing to do so will result in referential integrity violation</li>
                                        <li><b>Nullify</b> - set this field value to null (possible only for nullable fields)</li>
                                        <li><b>Cascade</b> - delete this object</li>
                                    </ul>
                                </td>
                            </tr>
                            <tr>
                                <td>prefetch</td>
                                <td>integer</td>
                                <td>Prefetch level for this field. See the <a href="#prefetch">prefetching objects</a> section for more information.</td>
                            </tr>
                            <tr>
                                <td>nullable</td>
                                <td>boolean</td>
                                <td>Allow this field to hold the null value. Exact <a href="#generatedproperties">representation of the null value</a> depends on options passed to <a href="#soodastubgen">SoodaStubGen</a>.</td>
                            </tr>
                            <tr>
                                <td>forceTrigger</td>
                                <td>boolean</td>
                                <td>Always generate <a href="#generatedtriggers">triggers</a> for this field even if <code>triggers</code> attribute for the enclosing class is set to <code>false</code>.</td>
                            </tr>
                            <tr>
                                <td>primaryKey</td>
                                <td>boolean</td>
                                <td>Mark this field as primary key. Each <a href="#schematable"><x><table /></x></a> must have at least one field marked as primary key.</td>
                            </tr>
                            <tr>
                                <td>precommitValue</td>
                                <td>depends on data type</td>
                                <td>The value to be used when <a href="#precommit">precommitting</a> not-nullable field and the value is not yet provided. Makes sense only for not-null fields.</td>
                            </tr>
                            <tr>
                                <td>find</td>
                                <td>boolean</td>
                                <td>
                                    <todo />
                                </td>
                            </tr>
                            <tr>
                                <td>findList</td>
                                <td>boolean</td>
                                <td>
                                    <todo />
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    There's no support for compound properties (that would map to more than one field), but it's relatively easy 
                    to do it by hand by adding a new property of the required type.
                </p>
            </body>
            <section id="schemadatatypes">
                <title>Supported data types</title>
                <body>
                    <p>
                        The following data types are supported for the <code>type</code> attribute of <a href="#schemafield"><x><field /></x></a>:
                    </p>
                    <div class="table">
                        <table>
                            <col style="font-family: Consolas, Courier New" />
                            <col style="font-family: Consolas, Courier New" />
                            <col style="font-family: Consolas, Courier New" />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>C# Type</th>
                                    <th>Database Type</th>
                                    <th>Comments</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td valign="top">Integer</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>int</li>
                                            <li>SqlInt32</li>
                                            <li>Nullable&lt;int&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">int (32-bit)</td>
                                    <td valign="top">For databases that dont't support 32-bit integers (such as Oracle) you can use the appropriate numeric type</td>
                                </tr>
                                <tr>
                                    <td valign="top">Long</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>long</li>
                                            <li>SqlInt64</li>
                                            <li>Nullable&lt;long&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">bigint (64-bit)</td>
                                    <td valign="top">For databases that dont't support 64-bit integers (such as Oracle) you can use the appropriate numeric type</td>
                                </tr>
                                <tr>
                                    <td valign="top">Boolean</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>bool</li>
                                            <li>SqlBoolean</li>
                                            <li>Nullable&lt;bool&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">bit</td>
                                    <td valign="top">The data provider should return the value in response to calling IDataReader.GetBoolean().</td>
                                </tr>
                                <tr>
                                    <td valign="top">BooleanAsInteger</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>bool</li>
                                            <li>SqlBoolean</li>
                                            <li>Nullable&lt;bool&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">int</td>
                                    <td valign="top">The database stores true as 1 and false as 0. When reading any value other than zero is considered "true" and zero is considered "false"</td>
                                </tr>
                                <tr>
                                    <td valign="top">Decimal</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>decimal</li>
                                            <li>SqlDecimal</li>
                                            <li>Nullable&lt;decimal&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">decimal</td>
                                    <td valign="top">
                                        The Decimal value type is appropriate for financial calculations requiring large numbers of 
                                        significant integral and fractional digits and no round-off errors.
                                    </td>
                                </tr>
                                <tr>
                                    <td valign="top">Float</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>float</li>
                                            <li>SqlSingle</li>
                                            <li>Nullable&lt;float&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">float</td>
                                    <td valign="top">32-bit precision floating point</td>
                                </tr>
                                <tr>
                                    <td valign="top">Double</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>double</li>
                                            <li>SqlDouble</li>
                                            <li>Nullable&lt;double&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">real</td>
                                    <td valign="top">64-bit precision floating point</td>
                                </tr>
                                <tr>
                                    <td valign="top">DateTime</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>DateTime</li>
                                            <li>SqlDateTime</li>
                                            <li>Nullable&lt;DateTime&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>datetime</li>
                                            <li>smalldatetime</li>
                                            <li>timestamp</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Date and/or time value</td>
                                </tr>
                                <tr>
                                    <td valign="top">String</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>String</li>
                                            <li>SqlString</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>nvarchar</li>
                                            <li>ntext</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Unicode String</td>
                                </tr>
                                <tr>
                                    <td valign="top">AnsiString</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>String</li>
                                            <li>SqlString</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>varchar</li>
                                            <li>text</li>
                                        </ul>
                                    </td>
                                    <td valign="top">ANSI String (8-bit characters)</td>
                                </tr>
                                <tr>
                                    <td valign="top">Blob</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>byte[]</li>
                                            <li>SqlBinary</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>binary</li>
                                            <li>varbinary</li>
                                            <li>image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Block of bytes</td>
                                </tr>
                                <tr>
                                    <td valign="top">Guid</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>Guid</li>
                                            <li>SqlGuid</li>
                                            <li>Nullable&lt;Guid&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>uniqueidentifier</li>
                                        </ul>
                                    </td>
                                    <td valign="top">128-bit randomly generated unique identifier.
                                        GUID is not guaranteed to be unique, but the number of GUIDS (2^128) is so large that the possibility of collision is very small.</td>
                                </tr>
                                <tr>
                                    <td valign="top">TimeSpan</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>TimeSpan</li>
                                            <li>Nullable&lt;TimeSpan&gt;</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>int</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Timespan value represented as integral number of seconds.</td>
                                </tr>
                                <tr>
                                    <td valign="top">Image</td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>System.Drawing.Image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">
                                        <ul class="noindent">
                                            <li>binary</li>
                                            <li>varbinary</li>
                                            <li>image</li>
                                        </ul>
                                    </td>
                                    <td valign="top">Block of bytes interpreted as image(picture) by the System.Drawing.Image class</td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
        </section>
        <section id="schemaconst">
            <title>Named Constants - <x><const /></x></title>
            <body>
                <p>
                    The <x><const /></x> element defines <a href="#generatedenums">named constants</a> to be generated. 
                    Each constant has a name and value, whose type depends on the primary key type of this class. Constants are
                    not supported for classes with compound primary keys or where the type of the primary key is other than Integer or
                    String.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class>
                        ...
                        <const name="..." value="..." />
                    </class>
                    ]]>
                </code>
                <p>
                    Example:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="User">
                        <table name="User">
                            <field name="ID" type="Integer" primaryKey="true" />
                            <field name="Name" type="String" size="40" />
                        </table>

                        <const name="Administrator" value="1" />
                        <const name="Guest" value="2" />
                        <const name="SystemUser" value="2" />
                    </class>
                    ]]>
                </code>
                <p>
                    Once you've defined the constants you may use them instead of calling classname.GetRef(). Note that you cannot
                    pass the instance of <a href="#soodatransaction">SoodaTransaction</a> so constants are limited to 
                    be used in the context of implicit transaction.
                </p>
                <code lang="C#">
                    User.GetRef(1) == User.Administrator
                    User.GetRef(2) == User.Guest
                    User.GetRef(3) == User.SystemUser
                </code>
            </body>
        </section>
        <section id="schema1N">
            <title>One-To-Many Relationships - <x><collectionOneToMany /></x></title>
            <body>
                <p>
                    One-to-many relationships are defined using <x><collectionOneToMany /></x> which needs to be placed inside <x><class /></x> element.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="className">
                        <field />
                        <field />
                        <field />
                        <field />
                        <collectionOneToMany name="COLLECTION_NAME" class="CHILD_CLASS" foreignField="FOREIGN_FIELD" />
                    </class>
                    ]]>
                </code>
                <p>
                    In short, it defines a collection named COLLECTION_NAME whose items are of class CHILD_CLASS where the value of
                    FOREIGN_FIELD equals to this object's primary key. In other words this is a list of objects referencing this object
                    through the specified reference field.
                </p>
                <p>
                    Sooda also supports additional attribute named <code>where</code> which can be used to define where clause to
                    be used when fetching objects. This can be used to create filtered collections:
                </p>
                <code lang="XML">
                    <![CDATA[
                    <class name="Group">
                        <collectionOneToMany name="Members" class="Person" foreignField="Group" />
                        <collectionOneToMany name="VipMembers" class="Person" foreignField="Group" where="IsVip = True" />
                    </class>
                    ]]>
                </code>
                <p>
                    The above example defines two collections in the Group class: one named <code>Members</code> holds all members of
                    the group, the other is named <code>VipMembers</code> and holds only members who are VIPs.
                </p>
                <p>
                    <b>CAUTION:</b> Collections defined with "where" are not recommended because they don't automatically reflect
                    the state of child objects when you manually change the foreignField. Collections without where clause
                    don't exhibit this problem.
                </p>
                <p>
                    The details about generated code can be found <sectionlink id="generatedcollections" />.
                </p>
            </body>
        </section>
        <section id="schemaNN">
            <title>Many-To-Many Relationships - <x><collectionManyToMany /></x> and <x><relation /></x></title>
            <body>
                <p>
                    Many-to-many relationships are defined using 
                    <x><collectionManyToMany /></x> in cooperation with the <x><relation /></x>.
                    The <x><collectionManyToMany /></x> needs to be placed inside <x><class /></x> element
                    and <x><relation /></x> needs to be placed inside <x><schema /></x> element.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema>
                        <class name="className">
                            ...
                            <collectionManyToMany name="COLLECTION_NAME" relation="RELATION" foreignField="FOREIGN_FIELD" />
                        </class>

                        <relation name="RELATION">
                            <table name="RELATION_TABLE">
                                <field name="f1" type="t1" primaryKey="true" references="R1" />
                                <field name="f2" type="t2" primaryKey="true" references="R2" />
                            </table>
                        </relation>
                    </schema>
                    ]]>
                </code>
                <p>
                    The <x><relation /></x> element defines a relation (table) that resolves many-to-many relationships.
                    It must include exactly two fields, which are references to other tables. 
                </p>
                <p>
                    Each record in this table represents a relationships between two objects pointed at by the fields.
                    For example, assuming we have a relation Contact2Group with 2 columns: contact_id and group_id
                    and it contains a row where contact_id=1 and group_id=7 it means that contact[1] and group[7] are in
                    (some) relationship. The name of the relationship is established by <x><collectionManyToMany /></x>.
                </p>
                <code lang="XML">
                    <![CDATA[
                    <relation name="Contact2Group">
                        <table name="Contact2Group">
                            <field name="TheContact" type="Integer" references="Contact" primaryKey="true" />
                            <field name="TheGroup" type="Integer" references="Group" primaryKey="true" />
                        </table>
                    </relation>
                    ]]>
                </code>
                <p>
                    Each side of the relation has a multiplicity of "many", which means each contact may be in relationship 
                    with many groups and each group can be in relationship with many contacts. This is represented
                    by a pair of strongly typed collections.
                </p>
                <p>
                    The collections are declared using <x><collectionManyToMany /></x>.
                </p>
                <code lang="C#">
                    class Contact
                    {
                        GroupList Groups { get; }
                    }

                    class Group
                    {
                        ContactList Members { get; }
                    }
                </code>
                <p>
                    The <x><collectionManyToMany /></x> declaration accepts the following attributes:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>name</b></td>
                                <td>string</td>
                                <td>Collection name</td>
                            </tr>
                            <tr>
                                <td><b>relation</b></td>
                                <td>string</td>
                                <td>Name of the relation (table) that represents the relationship.</td>
                            </tr>
                            <tr>
                                <td><b>foreignField</b></td>
                                <td>string</td>
                                <td>Name of the field defined in <x><relation /></x> that points back at the
                                    object that declares the collection. For example, considering the Contact2Group relation defined above,
                                    you should put this in <x><class name="Contact" /></x> to get Contact.Groups collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Contact">
                                            ...
                                            <collectionManyToMany name="Groups" relation="Contact2Group" foreignField="TheContact" />
                                        </class>
                                        ]]>
                                    </code>
                                    Symmetrically, you should put this in <x><class name="Group" /></x> to get the Group.Members collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Group">
                                            ...
                                            <collectionManyToMany name="Members" relation="Contact2Group" foreignField="TheGroup" />
                                        </class>
                                        ]]>
                                    </code>
                                    You can of course choose not to declare collections. This is a way to get unidirectional relationships.
                                </td>
                            </tr>
                            <tr>
                                <td>masterField</td>
                                <td>integer (0 or 1)</td>
                                <td>The ordinal of the field defined in <x><relation /></x> that points at the referenced object.
                                    Specifying this attribute is equivalent to providing the appropriate value of foreignField, but
                                    the meaning is reversed. The following declaration declares Contact.Groups and Group.Members collections:
                                    Then you should put this in <x><class name="Contact" /></x> to get Groups collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Contact">
                                            ...
                                            <collectionManyToMany name="Groups" relation="Contact2Group" masterField="1" />
                                        </class>
                                        ]]>
                                    </code>
                                    Symmetrically, you should put this in <x><class name="Group" /></x> to get the Members collection:
                                    <code lang="XML">
                                        <![CDATA[
                                        <class name="Group">
                                            ...
                                            <collectionManyToMany name="Members" relation="Contact2Group" masterField="0" />
                                        </class>
                                        ]]>
                                    </code>
                                    <b>
                                        OBSOLETE WARNING: It's recommended not to use masterField, but use foreignField instead. masterField
                                        is provided only for compatibility purposes and may be removed in future versions.
                                    </b>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    The details about generated code can be found in <sectionlink id="generatedcollections" />.
                </p>
            </body>
        </section>
        <section id="schemainclude">
            <title>Include Files - <x><include /></x></title>
            <body>
                <p>
                    Schemas can include one another. This is a way to split complex domain models into many manageable files
                    which are subject to separate compilation and code generation.
                </p>
                <p>
                    You need to use the <x><include /></x> to include another schema. The following attributes are supported.
                    (attributes marked with bold are required).
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td><b>schema</b></td>
                                <td>string</td>
                                <td>Path to the included schema. 
                                    The path is relative to the directory where the including schema is located.
                                </td>
                            </tr>
                            <tr>
                                <td><b>namespace</b></td>
                                <td>string</td>
                                <td>Namespace of the included schema. Sooda will generate the appropriate <b>using</b> clause.</td>
                            </tr>
                            <tr>
                                <td><b>assembly</b></td>
                                <td>string</td>
                                <td>Name of the assembly (without *.dll extension) that contains classes generated from the schema</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Example usage (assuming that SoodaSchema.xml is located in c:\MyProject the included file 
                    should be located in c:\MyProject\SharedBusinessObjects\SoodaSchema.xml):
                </p>
                <code lang="XML">
                    <![CDATA[
                    <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                        <include schema="SharedBusinessObjects/SoodaSchema.xml" namespace="MyCompany.SharedBusinessObjects" assembly="MyCompany.SharedBusinessObjects" />
                    </schema>
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemainheritance">
            <title>Inheritance</title>
            <body>
                <p>
                    In order to define <a href="#inheritance">inheritance relationship</a> you need to designate one class which will serve
                    as a root of the inheritance hierarchy and make other inherit (directly or indirectly) from it.
                    Attributes which control inheritance are specified at the <x><class /></x> level. They are:
                </p>
                <div class="table">
                    <table>
                        <col style="font-family: Consolas, Courier New" />
                        <col style="font-family: Consolas, Courier New" />
                        <thead>
                            <tr>
                                <th>Name</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>subclassSelectorField</td>
                                <td>string</td>
                                <td>
                                    <p>
                                        Specifies the name of the subclass selector field that determines this object type. The
                                        field must be defined in this <x><class /></x>, in the first <x><table /></x> and must
                                        be either integer or string. Based on the value stored in this field Sooda is
                                        able to instantiate objects of the appropriate class in a polymorphic manner.
                                        Values stored in this field correspond to concrete (non-abstract) classes and are defined
                                        using <code>subclassSelectorValue</code>. See examples below.
                                    </p>
                                    <p>
                                        The class that defines subclassSelectorField is named the root of inheritance hierarchy.
                                        You cannot put subclassSelectorField in any class that inherits from another class 
                                        (to form sub-hierarchies). This feature might be added in future versions of Sooda.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>inheritFrom</td>
                                <td>string</td>
                                <td>
                                    Inherits from the specified class. The class must either be the root of the inheritance hierarchy
                                    or inherit (directly or indirectly) from such a class. It is an error to inherit from a class
                                    that doesn't ultimately derive from a root class (that has <code>subclassSelectorField</code> defined).
                                </td>
                            </tr>
                            <tr>
                                <td>subclassSelectorValue</td>
                                <td>integer or string</td>
                                <td>
                                    <p>
                                        Specifies the value of the subclass selector field that determines this object type. This parameter
                                        must be is specified for each concrete (non-abstract) class in the inheritance hierarchy.
                                        Sooda will instantiate objects of the appropriate type based on a value of the subclassSelectorField.
                                        If the value is equal to subclassSelectorValue for a particular class, an instance of this
                                        class will be created to represent the object.
                                    </p>
                                    <p>
                                        If you don't specify the value for subclassSelectorValue, <a href="#soodaschematool">SoodaStubGen</a>
                                        will generate an abstract class that cannot be instantiated programmatically.
                                    </p>
                                    <p>
                                        Values provided in subclassSelectorValue are also used in polymorphic queries to
                                        limit the selected objects to instances of a particular class. For example if you
                                        get a list of objects of a particular class you may get objects of this class (provided that they are
                                        not abstract) and all non-abstract classes that derive from it, either directly or indirectly.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    The following table summarizes possible combinations of the above attributes:
                </p>
                <div class="table">
                    <table>
                        <col align="center" valign="top" width="10%" />
                        <col align="center" valign="top" width="10%" />
                        <col align="center" valign="top" width="10%" />
                        <col width="70%" />
                        <thead>
                            <tr>
                                <th>subclassSelectorField</th>
                                <th>subclassSelectorValue</th>
                                <th>inheritFrom</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>A class that doesn't participate in inheritance hierarchy</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>defined</td>
                                <td>not defined</td>
                                <td>Root non-abstract class. Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>Root abstract class (cannot create instances). Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>Non-root abstract class. Can have subclasses.</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>defined</td>
                                <td>Non-root non-abstract class. Can have subclasses. Can create instances.</td>
                            </tr>
                            <tr>
                                <td>defined</td>
                                <td>(any)</td>
                                <td>defined</td>
                                <td><b style="color: red">Not allowed.</b> Cannot define a class that has both subclassSelectorField and inherits from another class</td>
                            </tr>
                            <tr>
                                <td>not defined</td>
                                <td>defined</td>
                                <td>not defined</td>
                                <td><b style="color: red">Not allowed.</b> When providing subclassSelectorValue you need to also provide subclassSelectorField or inheritFrom</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
                <p>
                    Sooda supports two models of inheritance mapping: table-per-hierarchy (TPH) and table-per-subclass (TPS) as described <sectionlink id="inheritance" />.
                    They only differ in actual table names used to store fields in subclasses, so the configuration is similar. Assuming
                    the familiar table of WorkItems structure we can map it to classes using the provided schema:
                </p>
                <img src="doc7.gif" alt="TPT(TPS) representation of inheritance hierarchy" />
                <p>
                    The schema that maps this to a class hierarchy using TPS model is:
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <!-- Root class of the inheritance hierarchy. -->
                            <!-- Note that it is abstract because it doesn't define subclassSelectorValue -->
                            <class name="WorkItem" subclassSelectorField="Type">
                                <table name="WorkItem">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Type" type="Integer" />
                                    <field name="AssignedTo" type="Integer" />
                                    <field name="AssignedDate" type="DateTime" />
                                    <field name="DueDate" type="DateTime" />
                                </table>
                            </class>

                            <!-- Concrete class stored in QuestionWorkItem table, identified by Type=1 -->
                            <class name="QuestionWorkItem" subclassSelectorValue="1">
                                <table name="QuestionWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Question" type="String" size="40" />
                                    <field name="Answer" type="String" size="40" />
                                </table>
                            </class>
                            <!-- Concrete class stored in AnalysisWorkItem table, identified by Type=2 -->
                            <class name="AnalysisWorkItem" subclassSelectorValue="2">
                                <table name="AnalysisWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Subject" type="String" size="40" />
                                </table>
                            </class>

                            <!-- Concrete class stored in BugWorkItem table, identified by Type=3 -->
                            <class name="BugWorkItem" subclassSelectorValue="3">
                                <table name="BugWorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="BugID" type="Integer" />
                                    <field name="BugDescription" type="String" size="40" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    The mapping in TPH model is very similar. You only need to change the table names, so
                    that they are all "TPH_WorkItem". We'll also rename fields by prefixing them with acronyms
                    of concrete subclasses they belong to:
                </p>
                <img src="doc9.gif" alt="TPH model" />
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <!-- Root class of the inheritance hierarchy. -->
                            <!-- Note that it is abstract because it doesn't define subclassSelectorValue -->
                            <class name="WorkItem" subclassSelectorField="Type">
                                <table name="TPH_WorkItem">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Type" type="Integer" />
                                    <field name="AssignedTo" type="Integer" />
                                    <field name="AssignedDate" type="DateTime" />
                                    <field name="DueDate" type="DateTime" />
                                </table>
                            </class>

                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=1 -->
                            <class name="QuestionWorkItem" subclassSelectorValue="1">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Question" dbcolumn="QWI_Question" type="String" size="40" />
                                    <field name="Answer" dbcolumn="QWI_Answer" type="String" size="40" />
                                </table>
                            </class>
                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=2 -->
                            <class name="AnalysisWorkItem" subclassSelectorValue="2">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Subject" dbcolumn="AWI_Subject" type="String" size="40" />
                                </table>
                            </class>

                            <!-- Concrete class stored in TPH_WorkItem table, identified by Type=3 -->
                            <class name="BugWorkItem" subclassSelectorValue="3">
                                <table name="TPH_WorkItem">
                                    <!-- primary key must be repeated for each table -->
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="BugID" dbcolumn="BWI_BugID" type="Integer" />
                                    <field name="BugDescription" dbcolumn="BWI_BugDescription" type="String" size="40" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
            </body>
        </section>
        <section id="schemaprecommitvalues">
            <title>Precommit Values</title>
            <body>
                <p>
                    There are situations where Sooda needs to temporarily store an object in a database but the state of the object
                    prevents it from being able to do so. Typically this is because of a not-nullable column requiring a value that
                    has not been defined and we're executing a query that may potentially return the object. 
                </p>
                <p>
                    To overcome this issue, Sooda supports a mechanism of precommit values, which can be used instead of real values
                    just to make the object "save-able". There are 3 levels of precommit values:
                </p>
                <ul>
                    <li><b>per-datatype precommit value</b> - you can decide the value for each data type. For example you 
                        want to store -1 for all not-null integer fields or 2000-01-01 00:00:00 for all DateTime fields</li>
                    <li><b>per-class precommit value</b> - this is used whenever you store a foreign key (which persists a reference to
                        a class). You can specify that unspecified foreign keys to some particular class should be persisted as
                        a specified numeric or string value</li>
                    <li><b>per-field precommit value</b> - to be used for a particular field.</li>
                </ul>
                <p>
                    Rules of precommit are described <sectionlink id="precommit" />.
                </p>
                <p>
                    You can use <x><precommitValue /></x> elements in your schema to define <b>per-datatype precommit value</b>. This example
                    defines a precommit value of -1 for Integer fields, <i>***NONE***</i> string for all String fields and <i>***NOTHING***</i>
                    for all AnsiString fields. You should pick a value that you don't commonly search for in your queries.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <precommitValue type="Integer" value="-1" />
                            <precommitValue type="String" value="***NONE***" />
                            <precommitValue type="AnsiString" value="***NOTHING***" />
                        </schema>
                    ]]>
                </code>
                <p>
                    In order to define <b>per-class precommit value</b>, you use the defaultPrecommitValue on a class.
                    Typically you use this feature when your database uses foreign key constraints and defaultPrecommitValue
                    is a value of an object that is known to exist in the table.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <class name="User" defaultPrecommitValue="-1">
                                <table />
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    <b>Per-field precommit values</b> are defined on each <x><field /></x> using precommitValue attribute. The
                    following example defines a precommitValue for User.Manager field.
                </p>
                <code lang="XML">
                    <![CDATA[
                        <schema xmlns="http://www.sooda.org/schemas/SoodaSchema.xsd">
                            <datasource name="default" type="Sooda.Sql.SqlDataSource" />

                            <class name="User" defaultPrecommitValue="-1">
                                <table name="_User">
                                    <field name="ID" type="Integer" primaryKey="true" />
                                    <field name="Name" type="String" size="40" />
                                    <field name="Manager" type="Integer" precommitValue="1111" />
                                </table>
                            </class>
                        </schema>
                    ]]>
                </code>
                <p>
                    Setting per-field precommit value has the highest precedence. If you don't
                    provide it and the field is a reference field, the defaultPrecommitValue for the
                    referenced class is used. It that still doesn't lead to a usable precommit value,
                    Sooda uses the per-type default precommit value and if it isn't defined, 
                    the default "zero" value is used based on the datatype:
                </p>
                <div class="table">
                    <table>
                        <thead>
                            <tr>
                                <th>Data Type</th>
                                <th>Default Precommit Value</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td valign="top">Integer</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Long</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Boolean</td>
                                <td valign="top">false</td>
                            </tr>
                            <tr>
                                <td valign="top">BooleanAsInteger</td>
                                <td valign="top">0</td>
                            </tr>
                            <tr>
                                <td valign="top">Decimal</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">Float</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">Double</td>
                                <td valign="top">0.0</td>
                            </tr>
                            <tr>
                                <td valign="top">DateTime</td>
                                <td valign="top">00:00:00.0000000, January 1, 0001 (DateTime.MinValue)</td>
                            </tr>
                            <tr>
                                <td valign="top">String</td>
                                <td valign="top">(empty string)</td>
                            </tr>
                            <tr>
                                <td valign="top">AnsiString</td>
                                <td valign="top">(empty string)</td>
                            </tr>
                            <tr>
                                <td valign="top">Blob</td>
                                <td valign="top">(zero-length blob)</td>
                            </tr>
                            <tr>
                                <td valign="top">Guid</td>
                                <td valign="top">00000001-0000-0000-0000-000000000000</td>
                            </tr>
                            <tr>
                                <td valign="top">TimeSpan</td>
                                <td valign="top">00:00:00</td>
                            </tr>
                            <tr>
                                <td valign="top">Image</td>
                                <td valign="top">(zero-length blob)</td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
        </section>
    </section>
    <section id="compilation">
        <title>Compilation</title>
        <section id="compilationprocess">
            <title>Compilation Process</title>
            <body>
                <p>
                    Sooda provides a utility called <a href="#soodastubgen">SoodaStubGen</a> that generates stub source code for 
                    the Data Access Layer. The generated source code needs to be compiled with a standard C#/VB compiler to 
                    produce a working assembly. This section describes the compilation process in detail.
                </p>
                <p>
                    It is recommended to run SoodaStubGen as part of your (preferably fully automated and repeatable) build process so Sooda supports 
                    calling stub generator from a batch file, NAnt script or Visual Studio 2003/2005 solution 
                    (Visual Studio 2002 is not supported).
                </p>
                <p>
                    Sooda supports two compilation modes:
                </p>
                <ul>
                    <li><a href="#compilationprocessstandard">Standard Stub Compilation</a> - stubs and business classes are compiled together in a single compiler pass. 
                        This should be compatible with most languages and compilers, but can be slow for really large schemas (which generate huge stub classes). This mode also
                        causes Visual Studio to slow down.
                    </li>
                    <li><a href="#compilationprocessseparate">Separate Stub Compilation</a> - enables stubs to be precompiled to a separate *.dll, which speeds up large builds but has some drawbacks which are described.</li>
                </ul>
                <p>
                    Separate compilation of stubs is difficult because of cyclic dependency between stub classes and skeleton
                    classes, which exists because:
                </p>

                <ul>
                    <li>skeleton classes must <b>inherit</b> from stub classes</li>
                    <li>stub classes must <b>return references</b> to skeleton classes.</li>
                </ul>

                <p>
                    The following picture describes the problem. Note how Book_Stub class must be able to return references
                    to Person class and Person_Stub must be able to return Book objects. At the same time Book inherits
                    from Book_Stub and Person inherits from Person_Stub:
                </p>
                <img src="doc14.png" alt="Cyclic dependency between stubs and skeleton classes" />

                <p style="color: red">
                    <b>CAUTION</b> Separate Stub Compilation relies on the ability of C# compiler to compile DLLs which
                    reference each other (cyclic dependencies). SoodaCompileStubs is used to ensure the proper bootstrapping
                    of such inter-dependent DLLs. Microsoft C# compiler (v1.1 and v2.0) is supported
                    but Mono Project Compiler (mcs) isn't because it is unable to properly handle cyclic references.
                </p>
            </body>
            <section id="compilationprocessstandard">
                <title>Standard Stub Compilation</title>
                <body>
                    <p>
                        Standard Stub Compilation is a process of building Sooda-based data access library, which uses two utilities:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> which generates stub source code</li>
                        <li>C#/VB Compiler which compiles stub and application code together</li>
                    </ol>
                    <p>
                        The following picture provides an overview of the standard stub compilation process:
                    </p>
                    <img src="doc12.png" alt="Standard stub compilation" />
                    <p>
                        On input the process requires an XML document with <a href="#schema">O/R Mapping Schema</a>, typically
                        stored in a file named <code>SoodaSchema.xml</code>. Arguments to <a href="#soodastubgen">SoodaStubGen</a> 
                        can be either passed on the command line or through a special <a href="#soodaproject">XML project file</a> which
                        is easier to manage.
                    </p>
                    <p>
                        Build steps to produce business objects assembly are:
                    </p>
                    <ol>
                        <li>SoodaStubGen produces two files:
                            <ul>
                                <li><b>_Stubs.cs</b> (the extension is different for other languages) - stub source file</li>
                                <li><b>_DBSchema.bin</b> - resources file</li>
                            </ul>
                            It also generates one "skeleton" file for each <a href="#schemaclasses">class</a> defined in schema.
                            The files are named <code>ClassName.cs</code> where ClassName is the name of the class.
                            <b>The skeleton is only generated in the first run and is never automatically regenerated</b>
                            You can add your own properties and business methods in the skeleton and your changes will be preserved
                            when rebuilding project. "Skeleton" inherits from a "stub" class so you get access to all its
                            properties and methods.
                        </li>
                        <li>
                            Compiler (such as csc.exe for C# or vbc.exe for Visual Basic.NET) compiles the skeleton and stub files
                            together to produce business objects assembly (*.dll).
                        </li>
                    </ol>
                </body>
            </section>
            <section id="compilationprocessseparate">
                <title>Separate Stub Compilation</title>
                <body>
                    <p>
                        Separate Stub Compilation is a process in which you precompile stubs to a separate DLL and
                        rebuild the DLL only when the schema changes. This can save compile time for very large schemas
                        and can also make Visual Studio run faster (for some reason Visual Studio 2005 doesn't perform very
                        well on very large source files which SoodaStubGen creates).
                    </p>

                    <p>
                        The following utilities are required:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> which generates stub source code and source files necessary
                        to generate mini-stubs and full stubs.</li>
                    <li><a href="#soodacompilestubs">SoodaCompileStubs</a> which precompiles stubs to a DLL.</li>
                        <li>C#/VB Compiler which compiles application code referencing the precompiled stub DLL</li>
                    </ol>
                    <p>
                        The following picture provides an overview of the separate stub compilation process:
                    </p>
                    <img src="doc13.png" alt="Separate stub compilation" />
                    <p>
                        The steps of the separate stub compilation are:
                    </p>
                    <ol>
                        <li><a href="#soodastubgen">SoodaStubGen</a> generates stub source code for: stubs, mini-stubs and mini-skeletons as described <sectionlink id="compilationprocessfiles" />.</li>
                        <li><a href="#soodacompilestubs">SoodaCompileStubs</a> is invoked to bootstrap the stubs library. This process consists of the following steps:
                            <ol type="a">
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.Stubs.dll</code> from <code>_MiniStubs.csx</code>. 
                                    The DLL references Sooda.dll only.</li>
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.dll</code> from <code>_MiniSkeleton.csx</code> referencing
                                    <code>OutputAssemblyName.Stubs.dll</code> built in the previous step.</li>
                                <li>C# compiler is invoked to build <code>OutputAssemblyName.Stubs.dll</code> from <code>_Stubs.csx</code> replacing
                                    the DLL built in the first step. The newly compiled DLL references <code>OutputAssemblyName.dll</code> built in the
                                    second step.
                                </li>
                            </ol>
                        </li>
                    </ol>
                </body>
            </section>
            <section id="compilationprocessfiles">
                <title>Files used during the compilation process</title>
                <body>
                    <p>
                        The following files are created or used during the compilation process:
                    </p>
                    <div class="table">
                        <table>
                            <col />
                            <col width="70pt" align="center" />
                            <col width="70pt" align="center" />
                            <col width="70pt" align="center" />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Location</th>
                                    <th>Provided by user</th>
                                    <th>Generated</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>SoodaSchema.xml</td>
                                    <td>any</td>
                                    <td>Yes</td>
                                    <td>Yes/No</td>
                                    <td>Defines <a href="#schema">mapping schema</a>. Can be written by hand or 
                                        reverse-engineered from an existing database with the <a href="#soodaschematool">SoodaSchemaTool utility</a>.</td>
                                </tr>
                                <tr>
                                    <td>ProjectName.soodaproject</td>
                                    <td>any</td>
                                    <td>Yes</td>
                                    <td>No</td>
                                    <td>Defines code generation parameters. 
                                        The format of this file is described <sectionlink id="soodaproject" />.
                                        You may choose to not use this file, but pass all code generation parameters as command line arguments
                                        to <a href="#soodastubgen">SoodaStubGen utility</a> instead.</td>
                                </tr>
                                <tr>
                                    <td>_DBSchema.bin</td>
                                    <td>output directory</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        Binary version of SoodaSchema.xml. 
                                        Enables access to schema-level metadata at runtime. Must be embedded into the assembly that
                                        contains business objects. Optimized for fast loading and small size by using binary serialization.
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.cs</td>
                                    <td>output directory</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            Generated code for stub classes, list wrappers, factories and other opaque types that 
                                            should be compiled together to build a Data Access Layer. 
                                            More information about the generated code is available 
                                            in the <a href="#generatedcode">Generated Code section</a>.
                                        </p>
                                        <p>
                                            The exact extension of this file matches the selected language and is cs for C# and vb for VB.NET. 
                                            Other CodeDOM providers have their specific extensions.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>ClassName.cs</td>
                                    <td>output directory</td>
                                    <td>Yes</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            Skeleton classes. They are generated by <a href="#soodastubgen">SoodaStubGen</a> 
                                            the first time it is executed and are not regenerated later.
                                        </p>
                                        <p>
                                            You can put your business methods in these files. There is one skeleton class for 
                                            each <x><class /></x> defined in the <a href="#schema">mapping schema</a>.
                                            Each class N is stored in a file named "output directory/N.cs" (for C#) 
                                            and this cannot be changed by the user.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Generated code for stub classes, list wrappers, factories and other opaque types that 
                                            should be compiled together to build a Data Access Layer stubs library.  
                                            More information about the generated code is available 
                                            in the <a href="#generatedcode">Generated Code section</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_MiniStubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Miniature version of generated code for stub classes, list wrappers, factories.
                                            Miniature stub classes do not rely on skeleton classes so they can be compiled separately 
                                            during the <a href="#compilationprocessseparate">separate compilation bootstrap procedure</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_MiniSkeleton.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Miniature version of skeleton classes. The skeleton classes have no code other than
                                            constructors and they inherit from the appropriate stub classes. This is a temporary file
                                            and is used
                                            during the <a href="#compilationprocessseparate">separate compilation bootstrap procedure</a>.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>_Stubs.csx</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            Same as _Stubs.cs, but located in _Stubs.csx. This file is compiled to create the stubs
                                            assembly.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>OutputAssemblyName.Stubs.dll</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                            The resulting stubs assembly. You should reference this file each time you reference
                                            OutputAssemblyName.dll.
                                        </p>
                                    </td>
                                </tr>
                                <tr>
                                    <td>OutputAssemblyName.dll</td>
                                    <td>output directory/Stubs</td>
                                    <td>No</td>
                                    <td>Yes</td>
                                    <td>
                                        <p>
                                            <b>This file is used only in separate stubs compilation mode</b>
                                        </p>
                                        <p>
                                           Mini-skeletons assembly. Should not be removed or your application won't build properly.
                                        </p>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
            <section id="compilationprocessnant">
                <title>NAnt</title>
                <body>
                    <p>
                        Sooda supports NAnt tasks that can be used to automate the build process. They are contained in
                        the Sooda.NAnt.Tasks library and must be loaded before they can be used:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <loadtasks assembly="${sooda.dir}/Sooda.NAnt.Tasks.dll" />
                        </project>
                        ]]>
                    </code>
                    <p>
                        <x><sooda-generate-code /></x> task is an equivalent of the <a href="#soodastubgen">SoodaStubGen utility</a>.
                        Usage:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <loadtasks assembly="${sooda.dir}/Sooda.NAnt.Tasks.dll" />
                            <sooda-generate-code project="path/to/proj.soodaproject" />
                        </project>
                        ]]>
                    </code>
                    <p>
                        This is equivalent to calling SoodaStubGen with the name of the <a href="#soodaproject">soodaproject</a> file as an argument:
                    </p>
                    <code lang="XML">
                        <![CDATA[
                        <project>
                            <exec program="${sooda.dir}/SoodaStubGen.exe" commandline="path/to/proj.soodaproject" />
                        </project>
                        ]]>
                    </code>
                </body>
            </section>
            <section id="compilationvisualstudio">
                <title>Visual Studio</title>
                <body>
                    <p>
                        Automating Visual Studio builds using Sooda relies on the <code>Pre-Build Event</code> setting which invokes
                        <a href="#soodastubgen">SoodaStubGen.exe</a> and optionally <a href="#soodacompilestubs">SoodaCompileStubs.exe</a>.
                        It's possible to pass arbitrary command-line arguments to these commands, but it's recommended to use 
                        <a href="#soodaproject">Sooda Project Files</a> which make this process a simpler to manage.
                    </p>
                    <p>
                        To set the Pre-Build Event command line, open project properties in Visual Studio and locate "<code>Build Events</code>".
                        Recommended Pre-Build Event command line is (for .NET 1.1/Visual Studio 2003)
                    </p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-1.1\SoodaStubGen.exe" "$(ProjectName).soodaproject"
                    </code>
                    <p>
                        For .NET 2.0 / Visual Studio 2005:
                    </p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-2.0\SoodaStubGen.exe" "$(ProjectName).soodaproject"
                    </code>
                    <p>
                        SOODA_DIR environment variable must be set properly (it is automatically initialized by the installer). You may want to adjust
                        the path if you installed Sooda manually in some other location.
                    </p>
                    <p>
                        Visual Studio 2002 doesn't support Pre-build Events and therefore cannot invoke SoodaStubGen automatically.
                    </p>
                    <p>
                        To call <a href="#soodacompilestubs">SoodaCompileStubs</a> from within Visual Studio, add the appropriate code:
                    </p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-1.1\SoodaCompileStubs.exe" $(ProjectName) "$(ProjectDir)Stubs" "$(ProjectDir)AssemblyInfo.cs"
                    </code>
                    <p>or</p>
                    <code lang="C#">
                        "%SOODA_DIR%\bin\net-2.0\SoodaCompileStubs.exe" $(ProjectName) "$(ProjectDir)Stubs" "$(ProjectDir)AssemblyInfo.cs"
                    </code>
                </body>
            </section>
        </section>
        <section id="soodaproject">
            <title>Sooda Project Files - *.soodaproject</title>
            <body>
                <p>
                    Sooda Project Files are used to control the generation of stub source code with the <a href="#soodastubgen">SoodaStubGen utility</a>. 
                    Project files are easier to read and maintain than command-line arguments passed to SoodaStubGen.
                    Visual Studio supports Intellisense so editing them is easy, even without documentation.
                </p>
                <p>
                    Sooda Project file must be saved in a file with <code>*.soodaproject</code> extension.
                    It is an XML file, whose root element is <x><sooda-project /></x> and its
                    XML Namespace is <code>http://www.sooda.org/schemas/SoodaProject.xsd</code>
                </p>
                <code lang="XML">
                    <![CDATA[
                    <sooda-project xmlns="http://www.sooda.org/schemas/SoodaProject.xsd">
                        <!-- parameters go here -->
                    </sooda-project>                
                    ]]>
                </code>
                <p>
                    The following table describes elements which can be used in Sooda Project files:
                </p>
                <div class="table">
                    <table style="table-layout: fixed; width: 100%">
                        <col style="font-family: Consolas, Courier New; width: 4cm" />
                        <col style="font-family: Consolas, Courier New; width: 2cm" />
                        <col />
                        <thead>
                            <tr>
                                <th>XML Element</th>
                                <th>Type</th>
                                <th>Description</th>
                            </tr>
                        </thead>
                        <tbody>
                            <tr>
                                <td>schema-file</td>
                                <td>string</td>
                                <td>Path to the file that defines the <a href="#schema">mapping schema</a>.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><schema-file>MySoodaSchema.xml</schema-file></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>language</td>
                                <td>string</td>
                                <td>Specifies the programming language. Possible (case insensitive) values are:
                                    <ul>
                                        <li><b>CS, C#, CSharp</b></li>
                                        <li><b>VB, VB.NET</b></li>
                                        <li><b>C++/CLI</b></li>
                                        <li><b>MC++</b> - Managed C++</li>
                                        <li>alternatively you can provide a fully qualified class name (including assembly, primary key token) 
                                            of the CodeDOM provider.
                                        </li>
                                    </ul>
                                    <p>
                                        The default is <b>C#</b>.
                                    </p>
                                    <p>
                                        Examples:
                                    </p>
                                    <p>C#:</p>
                                    <pre class="XML">
                                        <x><language>c#</language></x>
                                    </pre>
                                    <p>VB.NET:</p>
                                    <pre class="XML">
                                        <x><language>vb</language></x>
                                    </pre>
                                    <p>VJ#</p>
                                    <pre class="XML">
                                        <x><language>Microsoft.VJSharp.VJSharpCodeProvider, VJSharpCodeProvider, Version=2.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a, processorArchitecture=x86</language></x>
                                    </pre>
                                    <p>Boo:</p>
                                    <pre class="XML">
                                        <x><language>Boo.Lang.CodeDom.BooCodeProvider, Boo.Lang.CodeDom</language></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-assembly</td>
                                <td>string</td>
                                <td>Name of the output assembly without the DLL extension.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-assembly>MyAssembly</output-assembly></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-namespace</td>
                                <td>string</td>
                                <td>Name of the output namespace.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-namespace>MyNamespace</output-namespace></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>output-path</td>
                                <td>string</td>
                                <td>Output path. By default it is "." which represents current working directory.
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                        <x><output-path>src\MyBusinessObjects</output-path></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>nullable-representation<br/>not-null-representation</td>
                                <td>string</td>
                                <td>Specifies how nullable and not-nullable fields are mapped to properties.
                                    Possible methods are discussed <sectionlink id="soodaprojectprimitiverep" />.
                                    <p>
                                        Default value for nullable representation is <b>SqlType</b> and 
                                        default not-null representation is <b>Raw</b>.
                                    </p>
                                    <p>
                                        Example:
                                    </p>
                                    <pre class="XML">
                                    <x><nullable-representation>Boxed</nullable-representation></x><br/>
                                    <x><not-null-representation>Raw</not-null-representation></x>
                            </pre></td>
                            </tr>
                            <tr>
                                <td>with-indexers</td>
                                <td>boolean</td>
                                <td>
                                    Generate indexers (Item() in VB, this[] in C#) for list wrappers. You should set this option
                                    to false for languages thatadon't have the concept of indexers (such as JScript.NET). 
                                    The default value is <b>true</b>.
                                    <pre class="XML">
                                        <x><with-indexers>false</with-indexers></x>
                                    </pre>
                                    This feature is experimental and should not be used in production code.
                                </td>
                            </tr>
                            <tr>
                                <td>null-propagation</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Enable null propagation for nullable properties and reference properties:
                                    </p>
                                    <pre class="XML">
                                        <x><null-propagation>true</null-propagation></x>
                                    </pre>
                                    <p>
                                        Enabling this option causes the following prolog code to be emitted for all property
                                        getters:
                                    </p>
                                    <code lang="C#">
                                        if (this == null)
                                            return null;
                                    </code>
                                    <p>
                                        Without this feature we would get a <code>NullReferenceException</code> when traversing a path
                                        expression where one of the non-trailing elements is null. Consider this code:
                                    </p>

                                    <code lang="C#">
                                        OrgUnit o = this.OrganizationUnit.Parent.Parent.Parent;
                                    </code>

                                    <p>
                                        Assuming that <code>this.OrganizationUnit.Parent == null</code>, this code will throw a 
                                        <code>NullReferenceException</code> when built without null propagation. When null propagation
                                        is enabled, however, it will assign <code>null</code> to <code>o</code> without throwing an exception.
                                    </p>
                                    <p>
                                        This feature is experimental and should be used with caution.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>loader-class</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Generate Load(), GetRef(), GetList(), FindByXXX() and FindListByXXX() static methods in a separate class called ClassNameLoader instead
                                        of ClassName.
                                    </p>
                                    <pre class="XML">
                                        <x><loader-class>true</loader-class></x>
                                    </pre>
                                    <p>
                                        Some languages such as VJ# do not properly support inherited classes having the
                                        same public static method with different return type (which would be needed to support inheritance
                                        in Sooda). To remedy this problem, this option causes the methods to be moved to a separate class.
                                    </p>
                                    <p>
                                        When <x><loader-class /></x> is set to <code>false</code>, you can use the following methods to load objects:
                                    </p>
                                    <code lang="C#">
                                        Contact.Load(10);
                                        Contact.GetRef(10);
                                        Contact.TryGet(10);
                                        Contact.GetList(whereClause);
                                        Contact.LoadSingleObject(whereClause);
                                    </code>
                                    <p>
                                        When <x><loader-class /></x> is set to <code>true</code>, you can use the following methods to load objects:
                                    </p>
                                    <code lang="C#">
                                        ContactLoader.Load(10);
                                        ContactLoader.GetRef(10);
                                        ContactLoader.TryGet(10);
                                        ContactLoader.GetList(whereClause);
                                        ContactLoader.LoadSingleObject(whereClause);
                                    </code>
                                </td>
                            </tr>
                            <tr>
                                <td>with-typed-queries</td>
                                <td>boolean</td>
                                <td>
                                    <p>This option causes the <a href="#soodastubgen">SoodaStubGen utility</a> to 
                                        emit <a href="#soqltypedqueries">SQOL typed queries</a>. By default it is <code>true</code>, you
                                        can disable typed queries if you plan to use <a href="#soqltext">text-based queries</a> exclusively.
                                    </p>
                                    <pre class="XML">
                                        <x><with-typed-queries>true</with-typed-queries></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>stubs-compiled-separately</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Enables <a href="#compilationprocessseparate">separate compilation of stubs</a>.
                                    </p>
                                    <pre class="XML">
                                        <x><stubs-compiled-separately>true</stubs-compiled-separately></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>file-per-namespace</td>
                                <td>boolean</td>
                                <td>
                                    <p>
                                        Write each namespace to a separate file:
                                    </p>
                                    <ul>
                                        <li><code>_Stubs.cs</code> - assembly-level attributes</li>
                                        <li><code>_Stubs.OutputNamespace.cs</code> - list wrappers and class loaders</li>
                                        <li><code>_Stubs.OutputNamespace.Stubs.cs</code> - stubs, factories, private typed query expression classes</li>
                                        <li><code>_Stubs.OutputNamespace.TypedQueries</code> - public typed query expression classes</li>
                                    </ul>
                                    <p>
                                        When this option is set to false, all files are written to <code>_Stubs.cs</code>.
                                    </p>
                                    <pre class="XML">
                                        <x><file-per-namespace>true</file-per-namespace></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>base-class-name</td>
                                <td>string</td>
                                <td>
                                    <p>
                                        Specifies the name of the class that all stubs should ultimately derive from. If you don't specify
                                        this parameter, all root stubs classes will derive from the SoodaObject class.
                                    </p>
                                    <pre class="XML">
                                        <x><base-class-name>AdditionalBaseClass</base-class-name></x>
                                    </pre>
                                    <p>
                                        More ways to override base classes are discussed <sectionlink id="generatedclasshierarchy" />.
                                    </p>
                                </td>
                            </tr>
                            <tr>
                                <td>embed-schema
                                    type</td>
                                <td>Xml|Binary</td>
                                <td>
                                    <p>Specifies the method of embedding schema in the result DLL. Can be either <code>Xml</code> or <code>Binary</code>.
                                        <code>Binary</code> causes the schema to be serialized in binary format, while <code>Xml</code> stores the schema in the XML format.
                                        You should use <code>Binary</code> (which is the default), because it gives better startup times and smaller file sizes, but if you need to perform some 
                                        text-level parsing of the XML, you can choose <code>Xml</code>.
                                    </p>
                                    <pre class="XML">
                                        <x><embed-schema>Binary</embed-schema></x>
                                    </pre>
                                </td>
                            </tr>
                            <tr>
                                <td>external-projects</td>
                                <td>array</td>
                                <td>
                                    <p>
                                        Defines external projects (such as Visual Studio projects) that need to be updated each time a new class is added to the schema. 
                                        Each project is represented by <x><project type="..." file="..." /></x>. 
                                        The following example XML defines two projects: one for Visual Studio 2003 
                                        and the other for Visual Studio 2005: 
                                    </p>
                                    <code lang="XML">
                                        <![CDATA[
                                        <external-projects>
                                            <project type="vs2003" file="MyProject.vs2003.csproj" />
                                            <project type="vs2005" file="MyProject.vs2005.csproj" />
                                        </external-projects>
                                        ]]>
                                    </code>
                                    <p>
                                        The paths are relative to the output directory. The following project types are available:
                                    </p>
                                    <ul>
                                        <li><b>vs2003</b> - Visual Studio 2003</li>
                                        <li><b>vs2005</b> - Visual Studio 2005</li>
                                        <li><b>null</b> - no project file</li>
                                    </ul>
                                    <p>
                                        Note that files (such as source files and embedded resources) can only be added to projects, they
                                        are not removed automatically. If you remove a class from the <a href="#schema">mapping schema</a>, 
                                        you need to manually remove the appropriate file from your project.
                                    </p>
                                </td>
                            </tr>
                        </tbody>
                    </table>
                </div>
            </body>
            <section id="soodaprojectprimitiverep">
                <title>Primitive Representations</title>
                <body>
                    The following values are for <code>nullable-representation</code> and <code>not-null-representation</code>:
                    <div class="table">
                        <table style="table-layout: fixed; width: 100%">
                            <col style="font-family: Consolas, Courier New; width: 3cm" />
                            <col />
                            <thead>
                                <tr>
                                    <th>Name</th>
                                    <th>Description</th>
                                </tr>
                            </thead>
                            <tbody>
                                <tr>
                                    <td>Boxed</td>
                                    <td>Use boxing to represent nullable values. Null value is represented 
                                        as <code>null</code> reference, but a cast is required to get to get the value. 
                                        This representation is not recommended because of the lack of the type safety.

                                        <code lang="C#">
                                            // test for null
                                            if (x.Field1 != null)
                                            {
                                                // retrieve non-null value
                                                int v = (int)x.Field1;

                                                // WARNING - no type checking at compilation time occurs
                                                // so the following will compile, but will fail at runtime:
                                                bool b = (bool)x.Field1;

                                                // set to null
                                                x.Field1 = null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Raw</td>
                                    <td>Represent nullable fields as properties of primitive types (int,bool,DateTime) 
                                        completely ignoring their null value. This is suitable for not-null fields, 
                                        but may be a bad idea for nullable fields.

                                        <code lang="C#">
                                            // retrieve non-null value
                                            int v = (int)x.Field1;

                                            // set to not null
                                            x.Field1 = 42;
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>RawWithIsNull</td>
                                    <td>Represent nullable fields as a pair of properties - one is of primitive 
                                        type and returns the value of the field, the other called <b>FieldName_IsNull</b> returns the 
                                        null flag for the field.

                                        <code lang="C#">
                                            // test for null
                                            if (!x.Field1_IsNull)
                                            {
                                                // retrieve non-null value
                                                int v = x.Field1;

                                                // set to null
                                                x._SetNull_Field1();

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>SqlType</td>
                                    <td>
                                        Represent nullable fields as the corresponding SqlTypes (value types from the System.Data.SqlTypes namespace).
                                        The following SqlTypes are available:
                                        <ul>
                                            <li>SqlInt32</li>
                                            <li>SqlInt64</li>
                                            <li>SqlBoolean</li>
                                            <li>SqlDateTime</li>
                                            <li>SqlDecimal</li>
                                            <li>SqlSingle</li>
                                            <li>SqlDouble</li>
                                            <li>SqlBinary</li>
                                            <li>SqlGuid</li>
                                        </ul>

                                        <code lang="C#">
                                            // test for null
                                            if (!x.Field1.IsNull)
                                            {
                                                // retrieve non-null value
                                                int v = x.Field1.Value;

                                                // set to null
                                                x.Field1 = SqlInt32.Null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                                <tr>
                                    <td>Nullable</td>
                                    <td>
                                        <p>
                                            Use <code>Nullable&lt;T&gt;</code> types available in .NET 2.0 and above.
                                            The following nullable types are supported:
                                        </p>
                                        <ul>
                                            <li>Nullable&lt;int&gt; - int?</li>
                                            <li>Nullable&lt;long&gt; - long?</li>
                                            <li>Nullable&lt;bool&gt; - bool?</li>
                                            <li>Nullable&lt;DateTime&gt; - DateTime?</li>
                                            <li>Nullable&lt;decimal&gt; - decimal?</li>
                                            <li>Nullable&lt;float&gt; - float?</li>
                                            <li>Nullable&lt;double&gt; - double?</li>
                                            <li>Nullable&lt;Guid&gt; - Guid?</li>
                                        </ul>
                                        <code lang="C#">
                                            // test for null
                                            if (x.Field1 != null)
                                            {
                                                // retrieve non-null value, no other casts are allowed here
                                                int v = (int)x.Field1;

                                                // set to null
                                                x.Field1 = null;

                                                // set to not-null
                                                x.Field1 = 42;
                                            }
                                        </code>
                                    </td>
                                </tr>
                            </tbody>
                        </table>
                    </div>
                </body>
            </section>
        </section>
    </section>
    <section id="api">
        <title>Application Programming Interface</title>
        <section id="soodatransaction">
            <title>SoodaTransaction</title>
            <body>
                <todo />
            </body>
            <section id="soodatransactioncreating">
                <title>Creating and managing transactions</title>
                <body>
                    <p>
                        Instances of <code>SoodaTransaction</code> must be created before any operation
                        on O/R-mapped objects. You need to properly close the transaction after you are
                        done with the objects. The best way to ensure that your transaction is closed
                        regardless of any exceptions that may occur is to use the <code>IDisposable</code> 
                        pattern and C# <code>using()</code> statement:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            // perform operations on Sooda objects here
                            t.Commit();
                        }
                    </code>
                    <p>
                        This code is equivalent to:
                    </p>
                    <code lang="C#">
                        SoodaTransaction t = new SoodaTransaction();
                        try
                        {
                            // operations here
                            t.Commit();
                        }
                        finally
                        {
                            t.Dispose();
                        }
                    </code>
                    <p>
                        Each transaction must be associated with a mapping schema which is embedded as a resource into the 
                        compiled DAL assembly. You need to configure the transaction to use the appropriate assembly. 
                        There are several ways to do it depending on how you are planning to use your DAL:
                    </p>
                    <ol>
                        <li>By passing the assembly as an argument to <code>SoodaTransaction</code> constructor:
                            <code lang="C#">
                                // _DatabaseSchema class is generated by StubGen.
                                using (SoodaTransaction t = new SoodaTransaction(typeof(_DatabaseSchema).Assembly))
                                {
                                }
                            </code>
                        </li>
                        <li>By setting the <code>ObjectsAssembly</code> property of an open transaction:
                            <code lang="C#">
                                using (SoodaTransaction t = new SoodaTransaction())
                                {
                                    t.ObjectsAssembly = typeof(_DatabaseSchema).Assembly;
                                }
                            </code>
                        </li>
                        <li>By setting the static property <code>SoodaTransaction.DefaultsObjectAssembly</code> which establishes default value for <code>ObjectsAssembly</code> on newly created transactions
                            <code lang="C#">
                                // you need to do it only once
                                SoodaTransaction.DefaultObjectsAssembly = typeof(_DatabaseSchema).Assembly;

                                using (SoodaTransaction t = new SoodaTransaction())
                                {
                                }
                            </code>
                        </li>
                        <li>By setting the assembly name in the <a href="#configuration">configuration file</a>.
                            <code lang="XML">
                                <![CDATA[
                                <configuration>
                                    <appSettings>
                                        <add key="sooda.defaultObjectsAssembly" value="MyObjectsAssembly" />
                                    </appSettings>
                                </configuration>
                                ]]>
                            </code>
                            <p>If your objects assembly is in the GAC, you need to use a fully qualified assembly name:</p>
                            <code lang="XML">
                                <![CDATA[
                                <configuration>
                                    <appSettings>
                                        <add key="sooda.defaultObjectsAssembly" value="MyObjectsAssembly, Version=1.1.12.1512, Culture=neutral, PublicKeyToken=0123456789abcdef" />
                                    </appSettings>
                                </configuration>
                                ]]>
                            </code>
                        </li>
                        <li>By adding <code>SoodaStubAssemblyAttribute</code> to all assemblies that will create SoodaTransaction objects
                            <code lang="C#">
                                using MyBusinessObjects;

                                [assembly: SoodaStubAssembly(typeof(_DatabaseSchema))]

                                class C1
                                {
                                    public static void Main()
                                    {
                                        using (SoodaTransaction t = new SoodaTransaction())
                                        {
                                        }
                                    }
                                }
                            </code>
                        </li>
                    </ol>
                </body>
            </section>
            <section id="soodatransactionimplicit">
                <title>Implicit transactions</title>
                <body>
                    <p>
                        As mentioned earlier, every object which inherits from <code>SoodaObject</code> must be associated with an instance
                        of <code>SoodaTransaction</code>. There are 3 ways to materialize objects which will be discussed in further sections:
                    </p>
                    <ul>
                        <li><a href="#creatingobjects">creating new objects</a> - using <code>new</code></li>
                        <li><a href="#loadingobjects">loading objects</a>- with <code>Load()</code> and <code>GetRef()</code>, <code>FindByXXX()</code>, <code>LoadSingleObject()</code></li>
                        <li><a href="#loadingcollections">loading collections of objects</a> - with <code>GetList()</code>, <code>FindListByXXX()</code></li>
                    </ul>
                    <p>
                        You need to pass transaction object when calling any of the above methods. It would be inconvenient
                        to require the transaction reference to be passed explicitly, therefore Sooda supports the concept of 
                        implicit active transaction (returned by <code>SoodaTransaction.ActiveTransaction</code> static property).
                        Implicit transaction is used when no explicit transaction has been provided.
                    </p>
                    <p>
                        SoodaStubGen generates all APIs in two versions: one that takes <code>SoodaTransaction</code> object as 
                        parameter and the other that assumes implicit transaction. 
                    </p>
                    <p><b>Using implicit transactions:</b></p>
                    <code lang="C#">
                        using (SoodaTransaction transaction = new SoodaTransaction())
                        {
                            Person person;
                            PersonList personList;

                            // object construction - implicit transaction
                            person = new Person();

                            // load single objects
                            person = Person.Load(10);
                            person = Person.GetRef(10);
                            person = Person.LoadSingleObject(PersonField.Name == "Mary Manager");
                            person = Person.FindByName("Mary Manager");

                            // load collection
                            personList = Person.GetList(PersonField.Name == "Mary Manager");
                            personList = Person.FindListByName("Mary%");
                        }
                    </code>
                    <p><b>Explicit transactions:</b> (note that each method call receives transaction as its first argument)</p>
                    <code lang="C#">
                        using (SoodaTransaction transaction = new SoodaTransaction(SoodaTransactionOptions.NoImplicit))
                        {
                            Person person;
                            PersonList personList;

                            // object construction - explicit transaction passed to constructor
                            person = new Person(transaction);

                            // load single objects - transaction passed as first argument
                            person = Person.Load(transaction, 10);
                            person = Person.GetRef(transaction, 10);
                            person = Person.LoadSingleObject(transaction, PersonField.Name == "Mary Manager");
                            person = Person.FindByName(transaction, "Mary Manager");

                            // load collection - transaction passed as first argument
                            personList = Person.GetList(transaction, PersonField.Name == "Mary Manager");
                            personList = Person.FindListByName(transaction, "Mary%");
                        }
                    </code>
                    <p>
                        When you create a new <code>SoodaTransaction</code> object it is automatically 
                        stored in <code>SoodaTransaction.ActiveTransaction</code> unless you
                        pass <code>SoodaTransactionOptions.NoImplicit</code> argument to the constructor. 
                        This property is restored to its old value when the transaction is closed/disposed, 
                        which means you can nest transactions in an intuitive manner:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t1 = new SoodaTransaction())
                        {
                            // t1 is implicit transaction
                            using (SoodaTransaction t2 = new SoodaTransaction())
                            {
                                // t2 is implicit transaction
                                using (SoodaTransaction t3 = new SoodaTransaction())
                                {
                                    // t3 is implicit transaction
                                }
                                // t2 is implicit transaction
                            }
                            // t1 is implicit transaction
                        }
                    </code>
                    <p>
                        <code>SoodaTransaction.ActiveTransaction</code> reference is usually stored in thread local storage, 
                        but other storage strategies are possible, as described <sectionlink id="activetransactionstrategy" />.
                    </p>
                    <p>
                        Examples in this document will use implicit transactions, unless mentioned otherwise.
                    </p>
                </body>
            </section>
        </section>
        <section id="creatingobjects">
            <title>Creating objects</title>
            <body>
                <p>
                    To create a new persistent object in Sooda you simply invoke its constructor, optionally passing the transaction
                    reference. There are 3 constructors generated by Sooda:
                </p>
                <ul>
                    <li>default constructor - takes no arguments and associates newly created object with the implicit transaction</li>
                    <li>constructor which takes <code>SoodaTransaction</code> as an argument - associates newly created object with the specific transaction</li>
                    <li>special constructor which takes <code>SoodaConstructor</code> as an argument - this 
                       constructor should never be called by the user code and is used internally by Sooda</li>
               </ul>
               <p>
                   Typical code to create object, set its properties and save to the database is:
               </p>
               <code lang="C#">
                   using (SoodaTransaction t = new SoodaTransaction())
                   {
                        // create new object

                        Person p = new Person();

                        // set properties
                        p.Name = "Nancy Newcomer";
                        p.Sex = "F";
                        p.Address = "1 Microsoft Way";
                        p.ZipCode = "98052";
                        p.City = "Redmond";
                        p.State = "WA";
                        p.BirthDate = new DateTime(1980, 1, 1);

                        // commit
                        t.Commit();
                   }
               </code>
               <p>
                   Sooda allows you to create more than one object in the transaction and will properly handle situations where
                   two newly created objects are dependent on one another. SQL <code>INSERT</code> operations
                   will be properly ordered when <code>Commit()</code> is called, the to ensure that all foreign
                   key constraints will be preserved.
                   The following example demonstrates this:
               </p>

               <code lang="C#">
                   using (SoodaTransaction t = new SoodaTransaction())
                   {
                        // We have a new customer who whishes to make his first order of two items
                        // We want to make this transactional

                        Customer c = new Customer();
                        Order o = new Order();
                        OrderItem i1 = new OrderItem();
                        OrderItem i2 = new OrderItem();

                        c.Name = "Caroline Customer";
                        c.Address = "...";

                        o.ShipTo = c.Address;
                        o.Customer = c;

                        i1.ItemType = Item.Foo;
                        i1.Quantity = 10;

                        i2.ItemType = Item.Bar;
                        i2.Quantity = 10;

                        o.Items.Add(i1);
                        o.Items.Add(i2);

                        t.Commit();

                        // Sooda properly orders the SQL INSERT statements:
                        //
                        // insert into Customer ...
                        // insert into Order ...
                        // insert into OrderItem ...
                        // insert into OrderItem ...
                        //
                        // Issuing the statements in other order may break referential identity constraints
                   }
               </code>
            </body>
        </section>
        <section id="loadingobjects">
            <title>Loading objects</title>
            <body>
                <p>
                    There are various ways to load objects from the database depending on the desired result:
                </p>
                <ul>
                    <li>Get a reference to the object without loading data from the database (lazy loading)</li>
                    <li>Load single object from the database given its primary key</li>
                    <li>Load single object or list of objects that match the specified criteria</li>
                    <li>Load all objects from a collection</li>
                </ul>
            </body>
            <section id="loadingobjectsgetref">
                <title>Loading objects by primary key</title>
                <body>
                    <p>
                        Sooda provides two ways to get a reference to an object given its primary key:
                    </p>
                    <ul>
                        <li><code>ClassName.GetRef()</code> - gets a reference to an object without loading its data</li>
                        <li><code>ClassName.Load()</code> - gets a reference to an object and loads its data</li>
                    </ul>
                    <p>
                        Lazy loading is a way to get a reference to the object without actually loading data from the
                        database. Propery values will be loaded on first read access. Getting object reference is very fast
                        and should be used when we do not need actual object data, just its reference, as 
                        described <sectionlink id="lazyloading" />.
                    </p>
                    <p>
                        The following example demonstrates basic concepts of lazy loading:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            Employee emp;

                            //////////////////////////////////////////


                            // get a reference to an object - no database access here
                            emp = Employee.GetRef(3);

                            // first READ - this causes the object to be loaded
                            // (roughly equivalent to SELECT * FROM Employee WHERE id = 3)
                            Console.WriteLine(emp.Name);

                            // display hire date - no need to access the database 
                            // as the data is already loaded
                            Console.WriteLine(emp.HireDate);

                            //////////////////////////////////////////

                            // get a reference and load object data
                            emp = Employee.Load(5);

                            // no database access here - data is already in memory
                            Console.WriteLine(emp.Name);

                            // no database access here - data is already in memory
                            Console.WriteLine(emp.HireDate);

                            //////////////////////////////////////////

                            // get a reference to another object

                            emp = Employee.GetRef(7);

                            // change the state of the object
                            // we do not need to load the object at all!
                            emp.Active = false;

                            // commit changes. this sends the following SQL to the database:
                            // UPDATE Employee SET Active=false WHERE ID=7
                            t.Commit();

                        }
                    </code>
                    <p>
                        Reference fields use <code>GetRef()</code> internally so that when you access a property that returns another object
                        this object usually starts in <code>Data Not Loaded</code> status.
                    </p>
                    <p>
                        Note that it's not always possible to provide a reference to an object without loading its data, so GetRef() 
                        may sometimes need to load the data. When you invoke <code>GetRef()</code> or <code>Load()</code> on an
                        object of class that has subclasses, Sooda needs to load a record from the database to check the concrete type
                        to instantiate. Fortunately Sooda has a Factory Cache mechanism to avoid loading
                        records more than once as described <sectionlink id="factorycache" />.
                    </p>
                </body>
            </section>
            <section id="loadingbyquery">
                <title>Loading objects matching specific criteria</title>
                <body>
                    <p>
                        Sooda has a <a href="#soql">query language called SOQL</a> that can be used to select
                        objects that meet the specific criteria. To get a list of matching objects you 
                        use <code>GetList()</code> method. To load a single object by SQL query use <code>LoadSingleObject()</code>.
                    </p>
                    <p>
                        <code>GetList()</code> method is overloaded to support various usage scenarios.
                        The most complex variant of the method takes 5 parameters, but <a href="soodastubgen">SoodaStubGen</a>
                        also generates simplified variants of the GetList() method which only accept 1,2,3 or 4 parameters. There are
                        32 overloads for each class.
                    </p>
                    <code lang="C#">
                        GetList(transaction, whereClause, topCount, orderBy, options);
                    </code>
                    <p>
                        The parameters are:
                    </p>
                    <ul>
                        <li><code>transaction</code> - (optional) transaction reference, if omitted <code>SoodaTransaction.ActiveTransaction</code> is used</li>
                        <li><code>whereClause</code> - filter clause, can be either <a href="#soodawhereclause">SoodaWhereClause</a> (for textual queries) or
                            <a href="#soqlbooleanexpression">SoqlBooleanExpression</a> for typed queries.</li>
                        <li><code>topCount</code> - (optional) maximum number of objects to retrieve - this is equivalent to <code>SELECT TOP n</code> SQL query</li>
                        <li><code>orderBy</code> - (optional) specifies the ordering of result objects</li>
                        <li><code>options</code> - (optional) various flags that specify options</li>
                    </ul>
                    <p>
                        For example, you can use the following code to run <a href="#soqltext">text-based SOQL query</a> to fetch at most 5 Persons living in Redmond, WA:
                    </p>
                    <code lang="C#">
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                new SoodaWhereClause("City={0} and State={1}", 
                                    "Redmond", "WA"), 5))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                    </code>
                    <p>
                        To run a typed query:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA"))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        To order the results by last name:
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA"), 
                                SoodaOrderBy.Ascending("LastName"))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                    <p>
                        Options you can pass to <code>GetList()</code> are flags defined in 
                        the <code>SoodaSnapshotOptions</code> enumeration. Their meaning is described below:
                    </p>
                    <ul>
                        <li><code>Default</code> - Default options</li>
                        <li><code>NoTransaction</code> - Don't apply changes made in transaction. Use this option to perform a 
                            database snapshot or when you are sure that none of transaction objects will affect the result. 
                            This helps speed things up a bit.</li>
                        <li><code>NoWriteObjects</code> - Don't precommit objects. Precommit is described <sectionlink id="precommit" />.</li>
                        <li><code>VerifyAfterLoad</code> - Verify after load. In the case of precommit it is possible that the result
                            list will include extra objects. Enabling this option causes the resulting objects to be re-evaluated
                            in memory</li>
                        <li><code>KeysOnly</code> - Load only the primary key values. Objects will be materialized but fields other than primary keys will require a database query.</li>
                        <li><code>Cache</code> - Load the collection items from cache if possible.</li>
                        <li><code>NoCache</code> - Don't load the collection from cache even if it would be possible to do so</li>
                        <li><code>PrefetchRelated</code> - Use prefetch definition from the schema to load related objects automatically</li>
                    </ul>
                    <p>
                        The most commonly used option here is <code>NoWriteObjects</code> which can be used to disable precommit. 
                        This example demonstrates passing this option to <code>GetList()</code>. Passing SoodaSnapshotOptions.NoWriteObjects
                        causes "<code>Nancy Newcomer</code>" to be absent from the list of returned objects. If we omitted this flag,
                        Sooda would <a href="#precommit">precommit</a> <code>newPerson</code> object by making the SQL <code>INSERT</code> and Nancy Newcomer would be
                        returned by the <code>GetList()</code>.
                    </p>
                    <code lang="C#">
                        <![CDATA[
                        using (SoodaTransaction t = new SoodaTransaction())
                        {
                            // add a person, whose address matches the following SOQL query
                            Person newPerson = new Person();

                            newPerson.Name = "Nancy Newcomer";
                            newPerson.City = "Redmond";
                            newPerson.State = "WA";

                            // GetList() without precommit - Nancy Newcomer is 
                            // not returned

                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA",
                                SoodaSnapshotOptions.NoWriteObjects))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }

                            // GetList() with precommit - Nancy Newcomer included 
                            // in the list of matching objects

                            foreach (Person p in Person.GetList(
                                PersonField.City == "Redmond" && PersonField.State == "WA"))
                            {
                                Console.WriteLine("name: {0}", p.Name);
                            }
                        }
                        ]]>
                    </code>
                </body>
            </section>
            <section id="loadingcollections">
                <title>Loading collections</title>
                <body>
                </body>
            </section>
        </section>
        <section id="objectidentity">
            <title>Object Identity Management</title>
            <body>
                <todo />
                <p>
                    This implies that in order to participate in O/R mapping
                    each database table needs to have one or more primary key columns (either natural or surrogate)
                    and you need to tell the mapper which columns are primary keys. The primary keys
                    must be properly maintained in the database (the best way is to create a UNIQUE index on primary
                    key columns). If you fail to do so (for example when there are many rows sharing the same
                    value in the primary key column), you may get all sorts of undefined behavior.
                </p>
                <p>
                    Sooda guarantees reference identity for objects retrieved from a database. It means
                    that if we make 2 or more queries which retrieve a particular row from the 
                    database in the same <a href="#transactions">transaction</a>
                    they are guaranteed to be be mapped to the same object so if we got objects o1 and o2 then <code>Object.ReferenceEquals(o1, o2) == true</code>
                    Some other O/R Mapping tools only guarantee object value equality, so the same
                    row retrieved from the database in multiple queries can be mapped to more than
                    one object in memory, so you only get:
                    <code>o1.Equals(o2) &amp;&amp; o2.Equals(o1)</code> but 
                    <code>Object.ReferenceEquals(o1, o2)</code> can be <code>false</code>.
                </p>
                <p>
                    Mechanism that ensures object identity is called L1 (transaction-level) caching. It also ensures that
                    object is never loaded from a database twice.
                </p>
            </body>
        </section>
        <section id="modifyingobjects">
            <title>Modifying objects</title>
            <body>
            </body>
        </section>
        <section id="modifyingcollections">
            <title>Modifying collections</title>
            <body>
            </body>
        </section>
        <section id="keygeneration">
            <title>Key Generation</title>
            <body>
            </body>
        </section>
        <section id="precommit">
            <title>Precommitting objects in transactions</title>
            <body>
            </body>
        </section>
        <section id="triggers">
            <title>Triggers</title>
            <body>
            </body>
        </section>
        <section id="optimizations">
            <title>Optimizations</title>
            <body>
            </body>
            <section id="prefetch">
                <title>Prefetching</title>
                <body>
                </body>
            </section>
            <section id="factorycache">
                <title>Factory Cache</title>
                <body>
                </body>
            </section>
            <section id="runtimecaching">
                <title>Level 2 Caching</title>
                <body>
                </body>
            </section>
        </section>
        <section id="soodaobject">
            <title>SoodaObject</title>
            <body>
            </body>
        </section>
        <section id="schemaapi">
            <title>Schema API</title>
            <body>
            </body>
        </section>
        <section id="ql">
            <title>Query API</title>
            <body>
            </body>
            <section id="soodawhereclause">
                <title>SoodaWhereClause</title>
                <body>
                </body>
            </section>
            <section id="soqlbooleanexpression">
                <title>SoqlBooleanExpression</title>
                <body>
                </body>
            </section>
        </section>
        <section id="fieldhandlers">
            <title>Field Handlers</title>
            <body>
            </body>
        </section>
        <section id="cachingapi">
            <title>Caching</title>
            <body>
            </body>
        </section>
        <section id="activetransactionstrategy">
            <title>ActiveTransaction strategies</title>
            <body>
            </body>
        </section>
        <section id="datasources">
            <title>Data Sources API</title>
            <body>
                <section id="sqldatasource">
                    <title>SQL Data Source</title>
                    <body>
                    </body>
                </section>
                <section id="otherdatasources">
                    <title>Implementing other Data Sources</title>
                    <body>
                    </body>
                </section>
                <section id="configuringdatasources">
                    <title>Configuring Data Source</title>
                    <body>
                    </body>
                </section>
            </body>
        </section>
    </section>
    <section id="generatedcode">
        <title>Generated Code</title>
        <body>
            <section id="generatedclasses">
                <title>Classes</title>
                <body>
                </body>
                <section id="generatedproperties">
                    <title>Properties</title>
                    <body>
                    </body>
                    <section id="generatedpropertiesboxed">
                        <title>Boxed</title>
                        <body>
                        </body>
                    </section>
                    <section id="generatedpropertiessqltypes">
                        <title>SqlTypes</title>
                        <body>
                        </body>
                    </section>
                    <section id="generatedpropertiesraw">
                        <title>Raw</title>
                        <body>
                        </body>
                    </section>
                    <section id="generatedpropertiesrawwithisnull">
                        <title>RawWithIsNull</title>
                        <body>
                        </body>
                    </section>
                    <section id="generatedpropertiesnullable">
                        <title>Nullable</title>
                        <body>
                        </body>
                    </section>
                </section>
                <section id="generatedcollections">
                    <title>Collections</title>
                    <body>
                    </body>
                </section>
                <section id="generatedtriggers">
                    <title>Triggers</title>
                    <body>
                    </body>
                </section>
            </section>
            <section id="generatedclasshierarchy">
                <title>Class hierarchy</title>
                <body>
                    <todo />
                    <img src="doc15.png" alt="Demonstration of base-class-name effect" />
                </body>
            </section>
            <section id="generatedenums">
                <title>Constants/Enumerations</title>
                <body>
                </body>
            </section>
            <section id="generatedlistwrappers">
                <title>Collections</title>
                <body>
                </body>
            </section>
            <section id="generatedfindmethods">
                <title>Find Methods</title>
                <body>
                </body>
            </section>
            <section id="generatedfactories">
                <title>Factories</title>
                <body>
                </body>
            </section>
            <section id="generatedtypedqueries">
                <title>Typed Queries</title>
                <body>
                </body>
            </section>
            <section id="generatedschema">
                <title>Schema</title>
                <body>
                </body>
            </section>
        </body>
    </section>
    <section id="soql">
        <title>Query Language - SOQL</title>
        <section id="soqltext">
            <title>Text-based Queries</title>
            <body>
            </body>
        </section>
        <section id="soqltypedqueries">
            <title>Typed Queries</title>
            <body>
            </body>
        </section>
    </section>
    <section id="tools">
        <title>Tools</title>
        <section id="soodastubgen">
            <title>SoodaStubGen</title>
            <body>
            </body>
        </section>
        <section id="soodacompilestubs">
            <title>SoodaCompileStubs</title>
            <body>
            </body>
        </section>
        <section id="soodafixkeygen">
            <title>SoodaFixKeygen</title>
            <body>
            </body>
        </section>
        <section id="soodaschematool">
            <title>SoodaSchemaTool</title>
            <body>
            </body>
        </section>
        <section id="soodaaddin">
            <title>SoodaAddin</title>
            <body>
            </body>
        </section>
    </section>
    <section id="configuration">
        <title>Configuration</title>
        <body>
        </body>
    </section>
    <section id="logging">
        <title>Logging</title>
        <body>
        </body>
    </section>
</content>
