//------------------------------------------------------------------------------
// <autogenerated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </autogenerated>
//------------------------------------------------------------------------------

using System;
using System.Collections;

namespace Sooda {


    /// <summary>
    ///  A strongly-typed collection of <see cref="Sooda.SoodaObject"/> objects.
    /// </summary>
    [Serializable]
    public
    class SoodaObjectCollection : ICollection, IList, IEnumerable, ICloneable {
#region Interfaces
        /// <summary>
        ///  Supports type-safe iteration over a <see cref="SoodaObjectCollection"/>.
        /// </summary>
        public interface ISoodaObjectCollectionEnumerator {
            /// <summary>
            ///  Gets the current element in the collection.
            /// </summary>
            Sooda.SoodaObject Current {get
                                       ;
                                      }

            /// <summary>
            ///  Advances the enumerator to the next element in the collection.
            /// </summary>
            /// <exception cref="InvalidOperationException">
            ///  The collection was modified after the enumerator was created.
            /// </exception>
            /// <returns>
            ///  <c>true</c> if the enumerator was successfully advanced to the next element;
            ///  <c>false</c> if the enumerator has passed the end of the collection.
            /// </returns>
            bool MoveNext();

            /// <summary>
            ///  Sets the enumerator to its initial position, before the first element in the collection.
            /// </summary>
            void Reset();
        }
#endregion

        private const int DEFAULT_CAPACITY = 16;

#region Implementation (data)

        private Sooda.SoodaObject[] m_array;
        private int m_count = 0;
        [NonSerialized]
        private int m_version = 0;
#endregion

#region Static Wrappers
        /// <summary>
        ///  Creates a synchronized (thread-safe) wrapper for a
        ///     <c>SoodaObjectCollection</c> instance.
        /// </summary>
        /// <returns>
        ///     An <c>SoodaObjectCollection</c> wrapper that is synchronized (thread-safe).
        /// </returns>
        public static SoodaObjectCollection Synchronized(SoodaObjectCollection list) {
            if (list == null)
                throw new ArgumentNullException("list");
            return new SyncSoodaObjectCollection(list);
        }

        /// <summary>
        ///  Creates a read-only wrapper for a
        ///     <c>SoodaObjectCollection</c> instance.
        /// </summary>
        /// <returns>
        ///     An <c>SoodaObjectCollection</c> wrapper that is read-only.
        /// </returns>
        public static SoodaObjectCollection ReadOnly(SoodaObjectCollection list) {
            if (list == null)
                throw new ArgumentNullException("list");
            return new ReadOnlySoodaObjectCollection(list);
        }
#endregion

#region Construction
        /// <summary>
        ///  Initializes a new instance of the <c>SoodaObjectCollection</c> class
        ///  that is empty and has the default initial capacity.
        /// </summary>
        public SoodaObjectCollection() {
            m_array = new Sooda.SoodaObject[DEFAULT_CAPACITY];
        }

        /// <summary>
        ///  Initializes a new instance of the <c>SoodaObjectCollection</c> class
        ///  that has the specified initial capacity.
        /// </summary>
        /// <param name="capacity">
        ///  The number of elements that the new <c>SoodaObjectCollection</c> is initially capable of storing.
        /// </param>
        public SoodaObjectCollection(int capacity) {
            m_array = new Sooda.SoodaObject[capacity];
        }

        /// <summary>
        ///  Initializes a new instance of the <c>SoodaObjectCollection</c> class
        ///  that contains elements copied from the specified <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="c">The <c>SoodaObjectCollection</c> whose elements are copied to the new collection.</param>
        public SoodaObjectCollection(SoodaObjectCollection c) {
            m_array = new Sooda.SoodaObject[c.Count];
            AddRange(c);
        }

        /// <summary>
        ///  Initializes a new instance of the <c>SoodaObjectCollection</c> class
        ///  that contains elements copied from the specified <see cref="Sooda.SoodaObject"/> array.
        /// </summary>
        /// <param name="a">The <see cref="Sooda.SoodaObject"/> array whose elements are copied to the new list.</param>
        public SoodaObjectCollection(Sooda.SoodaObject[] a) {
            m_array = new Sooda.SoodaObject[a.Length];
            AddRange(a);
        }

        protected enum Tag {
            Default
        }

        protected SoodaObjectCollection(Tag t) {
            m_array = null;
        }
#endregion

#region Operations (type-safe ICollection)
        /// <summary>
        ///  Gets the number of elements actually contained in the <c>SoodaObjectCollection</c>.
        /// </summary>
        public virtual int Count
        {
            get {
                return m_count;
            }
        }

        /// <summary>
        ///  Copies the entire <c>SoodaObjectCollection</c> to a one-dimensional
        ///  <see cref="Sooda.SoodaObject"/> array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Sooda.SoodaObject"/> array to copy to.</param>
        public virtual void CopyTo(Sooda.SoodaObject[] array) {
            this.CopyTo(array, 0);
        }

        /// <summary>
        ///  Copies the entire <c>SoodaObjectCollection</c> to a one-dimensional
        ///  <see cref="Sooda.SoodaObject"/> array, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Sooda.SoodaObject"/> array to copy to.</param>
        /// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        public virtual void CopyTo(Sooda.SoodaObject[] array, int start) {
            if (m_count > array.GetUpperBound(0) + 1 - start)
                throw new System.ArgumentException("Destination array was not long enough.");

            Array.Copy(m_array, 0, array, start, m_count);
        }

        /// <summary>
        ///  Gets a value indicating whether access to the collection is synchronized (thread-safe).
        /// </summary>
        /// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get {
                return m_array.IsSynchronized;
            }
        }

        /// <summary>
        ///  Gets an object that can be used to synchronize access to the collection.
        /// </summary>
        public virtual object SyncRoot
        {
            get {
                return m_array.SyncRoot;
            }
        }
#endregion

#region Operations (type-safe IList)
        /// <summary>
        ///  Gets or sets the <see cref="Sooda.SoodaObject"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="SoodaObjectCollection.Count"/>.</para>
        /// </exception>
        public virtual Sooda.SoodaObject this[int index]
        {
            get {
                ValidateIndex(index); // throws
                return m_array[index];
            }
            set {
                ValidateIndex(index); // throws
                ++m_version;
                m_array[index] = value;
            }
        }

        /// <summary>
        ///  Adds a <see cref="Sooda.SoodaObject"/> to the end of the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaObject"/> to be added to the end of the <c>SoodaObjectCollection</c>.</param>
        /// <returns>The index at which the value has been added.</returns>
        public virtual int Add(Sooda.SoodaObject item) {
            if (m_count == m_array.Length)
                EnsureCapacity(m_count + 1);

            m_array[m_count] = item;
            m_version++;

            return m_count++;
        }

        /// <summary>
        ///  Removes all elements from the <c>SoodaObjectCollection</c>.
        /// </summary>
        public virtual void Clear() {
            ++m_version;
            m_array = new Sooda.SoodaObject[DEFAULT_CAPACITY];
            m_count = 0;
        }

        /// <summary>
        ///  Creates a shallow copy of the <see cref="SoodaObjectCollection"/>.
        /// </summary>
        public virtual object Clone() {
            SoodaObjectCollection newColl = new SoodaObjectCollection(m_count);
            Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
            newColl.m_count = m_count;
            newColl.m_version = m_version;

            return newColl;
        }

        /// <summary>
        ///  Determines whether a given <see cref="Sooda.SoodaObject"/> is in the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaObject"/> to check for.</param>
        /// <returns><c>true</c> if <paramref name="item"/> is found in the <c>SoodaObjectCollection</c>; otherwise, <c>false</c>.</returns>
        public virtual bool Contains(Sooda.SoodaObject item) {
            for (int i = 0; i != m_count; ++i)
                if (m_array[i].Equals(item))
                    return true;
            return false;
        }

        /// <summary>
        ///  Returns the zero-based index of the first occurrence of a <see cref="Sooda.SoodaObject"/>
        ///  in the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaObject"/> to locate in the <c>SoodaObjectCollection</c>.</param>
        /// <returns>
        ///  The zero-based index of the first occurrence of <paramref name="item"/>
        ///  in the entire <c>SoodaObjectCollection</c>, if found; otherwise, -1.
        /// </returns>
        public virtual int IndexOf(Sooda.SoodaObject item) {
            for (int i = 0; i != m_count; ++i)
                if (m_array[i].Equals(item))
                    return i;
            return -1;
        }

        /// <summary>
        ///  Inserts an element into the <c>SoodaObjectCollection</c> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
        /// <param name="item">The <see cref="Sooda.SoodaObject"/> to insert.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="SoodaObjectCollection.Count"/>.</para>
        /// </exception>
        public virtual void Insert(int index, Sooda.SoodaObject item) {
            ValidateIndex(index, true); // throws

            if (m_count == m_array.Length)
                EnsureCapacity(m_count + 1);

            if (index < m_count) {
                Array.Copy(m_array, index, m_array, index + 1, m_count - index);
            }

            m_array[index] = item;
            m_count++;
            m_version++;
        }

        /// <summary>
        ///  Removes the first occurrence of a specific <see cref="Sooda.SoodaObject"/> from the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaObject"/> to remove from the <c>SoodaObjectCollection</c>.</param>
        /// <exception cref="ArgumentException">
        ///  The specified <see cref="Sooda.SoodaObject"/> was not found in the <c>SoodaObjectCollection</c>.
        /// </exception>
        public virtual void Remove(Sooda.SoodaObject item) {
            int i = IndexOf(item);
            if (i < 0)
                throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");

            ++m_version;
            RemoveAt(i);
        }

        /// <summary>
        ///  Removes the element at the specified index of the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="SoodaObjectCollection.Count"/>.</para>
        /// </exception>
        public virtual void RemoveAt(int index) {
            ValidateIndex(index); // throws

            m_count--;

            if (index < m_count) {
                Array.Copy(m_array, index + 1, m_array, index, m_count - index);
            }

            // We can't set the deleted entry equal to null, because it might be a value type.
            // Instead, we'll create an empty single-element array of the right type and copy it
            // over the entry we want to erase.
            Sooda.SoodaObject[] temp = new Sooda.SoodaObject[1];
            Array.Copy(temp, 0, m_array, m_count, 1);
            m_version++;
        }

        /// <summary>
        ///  Gets a value indicating whether the collection has a fixed size.
        /// </summary>
        /// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get {
                return false;
            }
        }

        /// <summary>
        ///  gets a value indicating whether the IList is read-only.
        /// </summary>
        /// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get {
                return false;
            }
        }
#endregion

#region Operations (type-safe IEnumerable)

        /// <summary>
        ///  Returns an enumerator that can iterate through the <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <returns>An <see cref="Enumerator"/> for the entire <c>SoodaObjectCollection</c>.</returns>
        public virtual ISoodaObjectCollectionEnumerator GetEnumerator() {
            return new Enumerator(this);
        }
#endregion

#region Public helpers (just to mimic some nice features of ArrayList)

        /// <summary>
        ///  Gets or sets the number of elements the <c>SoodaObjectCollection</c> can contain.
        /// </summary>
        public virtual int Capacity
        {
            get {
                return m_array.Length;
            }

            set {
                if (value < m_count)
                    value = m_count;

                if (value != m_array.Length) {
                    if (value > 0) {
                        Sooda.SoodaObject[] temp = new Sooda.SoodaObject[value];
                        Array.Copy(m_array, temp, m_count);
                        m_array = temp;
                    } else {
                        m_array = new Sooda.SoodaObject[DEFAULT_CAPACITY];
                    }
                }
            }
        }

        /// <summary>
        ///  Adds the elements of another <c>SoodaObjectCollection</c> to the current <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="x">The <c>SoodaObjectCollection</c> whose elements should be added to the end of the current <c>SoodaObjectCollection</c>.</param>
        /// <returns>The new <see cref="SoodaObjectCollection.Count"/> of the <c>SoodaObjectCollection</c>.</returns>
        public virtual int AddRange(SoodaObjectCollection x) {
            if (m_count + x.Count >= m_array.Length)
                EnsureCapacity(m_count + x.Count);

            Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
            m_count += x.Count;
            m_version++;

            return m_count;
        }

        /// <summary>
        ///  Adds the elements of a <see cref="Sooda.SoodaObject"/> array to the current <c>SoodaObjectCollection</c>.
        /// </summary>
        /// <param name="x">The <see cref="Sooda.SoodaObject"/> array whose elements should be added to the end of the <c>SoodaObjectCollection</c>.</param>
        /// <returns>The new <see cref="SoodaObjectCollection.Count"/> of the <c>SoodaObjectCollection</c>.</returns>
        public virtual int AddRange(Sooda.SoodaObject[] x) {
            if (m_count + x.Length >= m_array.Length)
                EnsureCapacity(m_count + x.Length);

            Array.Copy(x, 0, m_array, m_count, x.Length);
            m_count += x.Length;
            m_version++;

            return m_count;
        }

        /// <summary>
        ///  Sets the capacity to the actual number of elements.
        /// </summary>
        public virtual void TrimToSize() {
            this.Capacity = m_count;
        }

#endregion

#region Implementation (helpers)

        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="SoodaObjectCollection.Count"/>.</para>
        /// </exception>
        private void ValidateIndex(int i) {
            ValidateIndex(i, false);
        }

        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="SoodaObjectCollection.Count"/>.</para>
        /// </exception>
        private void ValidateIndex(int i, bool allowEqualEnd) {
            int max = (allowEqualEnd) ? (m_count) : (m_count - 1);
            if (i < 0 || i > max)
                throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
        }

        private void EnsureCapacity(int min) {
            int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
            if (newCapacity < min)
                newCapacity = min;

            this.Capacity = newCapacity;
        }

#endregion

#region Implementation (ICollection)

        void ICollection.CopyTo(Array array, int start) {
            Array.Copy(m_array, 0, array, start, m_count);
        }

#endregion

#region Implementation (IList)

        object IList.this[int i]
        {
            get {
                return (object)this[i];
            }
            set {
                this[i] = (Sooda.SoodaObject)value;
            }
        }

        int IList.Add(object x) {
            return this.Add((Sooda.SoodaObject)x);
        }

        bool IList.Contains(object x) {
            return this.Contains((Sooda.SoodaObject)x);
        }

        int IList.IndexOf(object x) {
            return this.IndexOf((Sooda.SoodaObject)x);
        }

        void IList.Insert(int pos, object x) {
            this.Insert(pos, (Sooda.SoodaObject)x);
        }

        void IList.Remove(object x) {
            this.Remove((Sooda.SoodaObject)x);
        }

        void IList.RemoveAt(int pos) {
            this.RemoveAt(pos);
        }

#endregion

#region Implementation (IEnumerable)

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator)(this.GetEnumerator());
        }

#endregion

#region Nested enumerator class
        /// <summary>
        ///  Supports simple iteration over a <see cref="SoodaObjectCollection"/>.
        /// </summary>
    private class Enumerator : IEnumerator, ISoodaObjectCollectionEnumerator {
#region Implementation (data)

            private SoodaObjectCollection m_collection;
            private int m_index;
            private int m_version;

#endregion

#region Construction

            /// <summary>
            ///  Initializes a new instance of the <c>Enumerator</c> class.
            /// </summary>
            /// <param name="tc"></param>
            internal Enumerator(SoodaObjectCollection tc) {
                m_collection = tc;
                m_index = -1;
                m_version = tc.m_version;
            }

#endregion

#region Operations (type-safe IEnumerator)

            /// <summary>
            ///  Gets the current element in the collection.
            /// </summary>
            public Sooda.SoodaObject Current
            {
                get {
                    return m_collection[m_index];
                }
            }

            /// <summary>
            ///  Advances the enumerator to the next element in the collection.
            /// </summary>
            /// <exception cref="InvalidOperationException">
            ///  The collection was modified after the enumerator was created.
            /// </exception>
            /// <returns>
            ///  <c>true</c> if the enumerator was successfully advanced to the next element;
            ///  <c>false</c> if the enumerator has passed the end of the collection.
            /// </returns>
            public bool MoveNext() {
                if (m_version != m_collection.m_version)
                    throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

                ++m_index;
                return (m_index < m_collection.Count) ? true : false;
            }

            /// <summary>
            ///  Sets the enumerator to its initial position, before the first element in the collection.
            /// </summary>
            public void Reset() {
                m_index = -1;
            }
#endregion

#region Implementation (IEnumerator)

            object IEnumerator.Current
            {
                get {
                    return (object)(this.Current);
                }
            }

#endregion

        }
#endregion

#region Nested Syncronized Wrapper class
    private class SyncSoodaObjectCollection : SoodaObjectCollection {
#region Implementation (data)
            private SoodaObjectCollection m_collection;
            private object m_root;
#endregion

#region Construction

            internal SyncSoodaObjectCollection(SoodaObjectCollection list) : base(Tag.Default) {
                m_root = list.SyncRoot;
                m_collection = list;
            }
#endregion

#region Type-safe ICollection
            public override void CopyTo(Sooda.SoodaObject[] array) {
                lock (this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(Sooda.SoodaObject[] array, int start) {
                lock (this.m_root)
                    m_collection.CopyTo(array, start);
            }
            public override int Count
            {
                get {
                    lock (this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get {
                    return true;
                }
            }

            public override object SyncRoot
            {
                get {
                    return this.m_root;
                }
            }
#endregion

#region Type-safe IList
            public override Sooda.SoodaObject this[int i]
            {
                get {
                    lock (this.m_root)
                        return m_collection[i];
                }
                set {
                    lock (this.m_root)
                        m_collection[i] = value;
                }
            }

            public override int Add(Sooda.SoodaObject x) {
                lock (this.m_root)
                    return m_collection.Add(x);
            }

            public override void Clear() {
                lock (this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(Sooda.SoodaObject x) {
                lock (this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(Sooda.SoodaObject x) {
                lock (this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, Sooda.SoodaObject x) {
                lock (this.m_root)
                    m_collection.Insert(pos, x);
            }

            public override void Remove(Sooda.SoodaObject x) {
                lock (this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos) {
                lock (this.m_root)
                    m_collection.RemoveAt(pos);
            }

            public override bool IsFixedSize
            {
                get {
                    return m_collection.IsFixedSize;
                }
            }

            public override bool IsReadOnly
            {
                get {
                    return m_collection.IsReadOnly;
                }
            }
#endregion

#region Type-safe IEnumerable
            public override ISoodaObjectCollectionEnumerator GetEnumerator() {
                lock (m_root)
                    return m_collection.GetEnumerator();
            }
#endregion

#region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get {
                    lock (this.m_root)
                        return m_collection.Capacity;
                }

                set {
                    lock (this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(SoodaObjectCollection x) {
                lock (this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(Sooda.SoodaObject[] x) {
                lock (this.m_root)
                    return m_collection.AddRange(x);
            }
#endregion

        }
#endregion

#region Nested Read Only Wrapper class
    private class ReadOnlySoodaObjectCollection : SoodaObjectCollection {
#region Implementation (data)
            private SoodaObjectCollection m_collection;
#endregion

#region Construction

            internal ReadOnlySoodaObjectCollection(SoodaObjectCollection list) : base(Tag.Default) {
                m_collection = list;
            }
#endregion

#region Type-safe ICollection
            public override void CopyTo(Sooda.SoodaObject[] array) {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(Sooda.SoodaObject[] array, int start) {
                m_collection.CopyTo(array, start);
            }
            public override int Count
            {
                get {
                    return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get {
                    return m_collection.IsSynchronized;
                }
            }

            public override object SyncRoot
            {
                get {
                    return this.m_collection.SyncRoot;
                }
            }
#endregion

#region Type-safe IList
            public override Sooda.SoodaObject this[int i]
            {
                get {
                    return m_collection[i];
                }
                set {
                    throw new NotSupportedException("This is a Read Only Collection and can not be modified");
                }
            }

            public override int Add(Sooda.SoodaObject x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Clear() {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(Sooda.SoodaObject x) {
                return m_collection.Contains(x);
            }

            public override int IndexOf(Sooda.SoodaObject x) {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, Sooda.SoodaObject x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(Sooda.SoodaObject x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool IsFixedSize
            {
                get {
                    return true;
                }
            }

            public override bool IsReadOnly
            {
                get {
                    return true;
                }
            }
#endregion

#region Type-safe IEnumerable
            public override ISoodaObjectCollectionEnumerator GetEnumerator() {
                return m_collection.GetEnumerator();
            }
#endregion

#region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get {
                    return m_collection.Capacity;
                }

                set {
                    throw new NotSupportedException("This is a Read Only Collection and can not be modified");
                }
            }

            public override int AddRange(SoodaObjectCollection x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(Sooda.SoodaObject[] x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
#endregion

        }
#endregion

    }

}

namespace Sooda {


    /// <summary>
    ///  A strongly-typed collection of <see cref="Sooda.SoodaDataSource"/> objects.
    /// </summary>
    [Serializable]
    public
    class DataSourceCollection : ICollection, IList, IEnumerable, ICloneable {
#region Interfaces
        /// <summary>
        ///  Supports type-safe iteration over a <see cref="DataSourceCollection"/>.
        /// </summary>
        public interface IDataSourceCollectionEnumerator {
            /// <summary>
            ///  Gets the current element in the collection.
            /// </summary>
            Sooda.SoodaDataSource Current {get
                                           ;
                                          }

            /// <summary>
            ///  Advances the enumerator to the next element in the collection.
            /// </summary>
            /// <exception cref="InvalidOperationException">
            ///  The collection was modified after the enumerator was created.
            /// </exception>
            /// <returns>
            ///  <c>true</c> if the enumerator was successfully advanced to the next element;
            ///  <c>false</c> if the enumerator has passed the end of the collection.
            /// </returns>
            bool MoveNext();

            /// <summary>
            ///  Sets the enumerator to its initial position, before the first element in the collection.
            /// </summary>
            void Reset();
        }
#endregion

        private const int DEFAULT_CAPACITY = 16;

#region Implementation (data)

        private Sooda.SoodaDataSource[] m_array;
        private int m_count = 0;
        [NonSerialized]
        private int m_version = 0;
#endregion

#region Static Wrappers
        /// <summary>
        ///  Creates a synchronized (thread-safe) wrapper for a
        ///     <c>DataSourceCollection</c> instance.
        /// </summary>
        /// <returns>
        ///     An <c>DataSourceCollection</c> wrapper that is synchronized (thread-safe).
        /// </returns>
        public static DataSourceCollection Synchronized(DataSourceCollection list) {
            if (list == null)
                throw new ArgumentNullException("list");
            return new SyncDataSourceCollection(list);
        }

        /// <summary>
        ///  Creates a read-only wrapper for a
        ///     <c>DataSourceCollection</c> instance.
        /// </summary>
        /// <returns>
        ///     An <c>DataSourceCollection</c> wrapper that is read-only.
        /// </returns>
        public static DataSourceCollection ReadOnly(DataSourceCollection list) {
            if (list == null)
                throw new ArgumentNullException("list");
            return new ReadOnlyDataSourceCollection(list);
        }
#endregion

#region Construction
        /// <summary>
        ///  Initializes a new instance of the <c>DataSourceCollection</c> class
        ///  that is empty and has the default initial capacity.
        /// </summary>
        public DataSourceCollection() {
            m_array = new Sooda.SoodaDataSource[DEFAULT_CAPACITY];
        }

        /// <summary>
        ///  Initializes a new instance of the <c>DataSourceCollection</c> class
        ///  that has the specified initial capacity.
        /// </summary>
        /// <param name="capacity">
        ///  The number of elements that the new <c>DataSourceCollection</c> is initially capable of storing.
        /// </param>
        public DataSourceCollection(int capacity) {
            m_array = new Sooda.SoodaDataSource[capacity];
        }

        /// <summary>
        ///  Initializes a new instance of the <c>DataSourceCollection</c> class
        ///  that contains elements copied from the specified <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="c">The <c>DataSourceCollection</c> whose elements are copied to the new collection.</param>
        public DataSourceCollection(DataSourceCollection c) {
            m_array = new Sooda.SoodaDataSource[c.Count];
            AddRange(c);
        }

        /// <summary>
        ///  Initializes a new instance of the <c>DataSourceCollection</c> class
        ///  that contains elements copied from the specified <see cref="Sooda.SoodaDataSource"/> array.
        /// </summary>
        /// <param name="a">The <see cref="Sooda.SoodaDataSource"/> array whose elements are copied to the new list.</param>
        public DataSourceCollection(Sooda.SoodaDataSource[] a) {
            m_array = new Sooda.SoodaDataSource[a.Length];
            AddRange(a);
        }

        protected enum Tag {
            Default
        }

        protected DataSourceCollection(Tag t) {
            m_array = null;
        }
#endregion

#region Operations (type-safe ICollection)
        /// <summary>
        ///  Gets the number of elements actually contained in the <c>DataSourceCollection</c>.
        /// </summary>
        public virtual int Count
        {
            get {
                return m_count;
            }
        }

        /// <summary>
        ///  Copies the entire <c>DataSourceCollection</c> to a one-dimensional
        ///  <see cref="Sooda.SoodaDataSource"/> array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Sooda.SoodaDataSource"/> array to copy to.</param>
        public virtual void CopyTo(Sooda.SoodaDataSource[] array) {
            this.CopyTo(array, 0);
        }

        /// <summary>
        ///  Copies the entire <c>DataSourceCollection</c> to a one-dimensional
        ///  <see cref="Sooda.SoodaDataSource"/> array, starting at the specified index of the target array.
        /// </summary>
        /// <param name="array">The one-dimensional <see cref="Sooda.SoodaDataSource"/> array to copy to.</param>
        /// <param name="start">The zero-based index in <paramref name="array"/> at which copying begins.</param>
        public virtual void CopyTo(Sooda.SoodaDataSource[] array, int start) {
            if (m_count > array.GetUpperBound(0) + 1 - start)
                throw new System.ArgumentException("Destination array was not long enough.");

            Array.Copy(m_array, 0, array, start, m_count);
        }

        /// <summary>
        ///  Gets a value indicating whether access to the collection is synchronized (thread-safe).
        /// </summary>
        /// <returns>true if access to the ICollection is synchronized (thread-safe); otherwise, false.</returns>
        public virtual bool IsSynchronized
        {
            get {
                return m_array.IsSynchronized;
            }
        }

        /// <summary>
        ///  Gets an object that can be used to synchronize access to the collection.
        /// </summary>
        public virtual object SyncRoot
        {
            get {
                return m_array.SyncRoot;
            }
        }
#endregion

#region Operations (type-safe IList)
        /// <summary>
        ///  Gets or sets the <see cref="Sooda.SoodaDataSource"/> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index of the element to get or set.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="DataSourceCollection.Count"/>.</para>
        /// </exception>
        public virtual Sooda.SoodaDataSource this[int index]
        {
            get {
                ValidateIndex(index); // throws
                return m_array[index];
            }
            set {
                ValidateIndex(index); // throws
                ++m_version;
                m_array[index] = value;
            }
        }

        /// <summary>
        ///  Adds a <see cref="Sooda.SoodaDataSource"/> to the end of the <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaDataSource"/> to be added to the end of the <c>DataSourceCollection</c>.</param>
        /// <returns>The index at which the value has been added.</returns>
        public virtual int Add(Sooda.SoodaDataSource item) {
            if (m_count == m_array.Length)
                EnsureCapacity(m_count + 1);

            m_array[m_count] = item;
            m_version++;

            return m_count++;
        }

        /// <summary>
        ///  Removes all elements from the <c>DataSourceCollection</c>.
        /// </summary>
        public virtual void Clear() {
            ++m_version;
            m_array = new Sooda.SoodaDataSource[DEFAULT_CAPACITY];
            m_count = 0;
        }

        /// <summary>
        ///  Creates a shallow copy of the <see cref="DataSourceCollection"/>.
        /// </summary>
        public virtual object Clone() {
            DataSourceCollection newColl = new DataSourceCollection(m_count);
            Array.Copy(m_array, 0, newColl.m_array, 0, m_count);
            newColl.m_count = m_count;
            newColl.m_version = m_version;

            return newColl;
        }

        /// <summary>
        ///  Determines whether a given <see cref="Sooda.SoodaDataSource"/> is in the <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaDataSource"/> to check for.</param>
        /// <returns><c>true</c> if <paramref name="item"/> is found in the <c>DataSourceCollection</c>; otherwise, <c>false</c>.</returns>
        public virtual bool Contains(Sooda.SoodaDataSource item) {
            for (int i = 0; i != m_count; ++i)
                if (m_array[i].Equals(item))
                    return true;
            return false;
        }

        /// <summary>
        ///  Returns the zero-based index of the first occurrence of a <see cref="Sooda.SoodaDataSource"/>
        ///  in the <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaDataSource"/> to locate in the <c>DataSourceCollection</c>.</param>
        /// <returns>
        ///  The zero-based index of the first occurrence of <paramref name="item"/>
        ///  in the entire <c>DataSourceCollection</c>, if found; otherwise, -1.
        /// </returns>
        public virtual int IndexOf(Sooda.SoodaDataSource item) {
            for (int i = 0; i != m_count; ++i)
                if (m_array[i].Equals(item))
                    return i;
            return -1;
        }

        /// <summary>
        ///  Inserts an element into the <c>DataSourceCollection</c> at the specified index.
        /// </summary>
        /// <param name="index">The zero-based index at which <paramref name="item"/> should be inserted.</param>
        /// <param name="item">The <see cref="Sooda.SoodaDataSource"/> to insert.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="DataSourceCollection.Count"/>.</para>
        /// </exception>
        public virtual void Insert(int index, Sooda.SoodaDataSource item) {
            ValidateIndex(index, true); // throws

            if (m_count == m_array.Length)
                EnsureCapacity(m_count + 1);

            if (index < m_count) {
                Array.Copy(m_array, index, m_array, index + 1, m_count - index);
            }

            m_array[index] = item;
            m_count++;
            m_version++;
        }

        /// <summary>
        ///  Removes the first occurrence of a specific <see cref="Sooda.SoodaDataSource"/> from the <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="item">The <see cref="Sooda.SoodaDataSource"/> to remove from the <c>DataSourceCollection</c>.</param>
        /// <exception cref="ArgumentException">
        ///  The specified <see cref="Sooda.SoodaDataSource"/> was not found in the <c>DataSourceCollection</c>.
        /// </exception>
        public virtual void Remove(Sooda.SoodaDataSource item) {
            int i = IndexOf(item);
            if (i < 0)
                throw new System.ArgumentException("Cannot remove the specified item because it was not found in the specified Collection.");

            ++m_version;
            RemoveAt(i);
        }

        /// <summary>
        ///  Removes the element at the specified index of the <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="index">The zero-based index of the element to remove.</param>
        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="DataSourceCollection.Count"/>.</para>
        /// </exception>
        public virtual void RemoveAt(int index) {
            ValidateIndex(index); // throws

            m_count--;

            if (index < m_count) {
                Array.Copy(m_array, index + 1, m_array, index, m_count - index);
            }

            // We can't set the deleted entry equal to null, because it might be a value type.
            // Instead, we'll create an empty single-element array of the right type and copy it
            // over the entry we want to erase.
            Sooda.SoodaDataSource[] temp = new Sooda.SoodaDataSource[1];
            Array.Copy(temp, 0, m_array, m_count, 1);
            m_version++;
        }

        /// <summary>
        ///  Gets a value indicating whether the collection has a fixed size.
        /// </summary>
        /// <value>true if the collection has a fixed size; otherwise, false. The default is false</value>
        public virtual bool IsFixedSize
        {
            get {
                return false;
            }
        }

        /// <summary>
        ///  gets a value indicating whether the IList is read-only.
        /// </summary>
        /// <value>true if the collection is read-only; otherwise, false. The default is false</value>
        public virtual bool IsReadOnly
        {
            get {
                return false;
            }
        }
#endregion

#region Operations (type-safe IEnumerable)

        /// <summary>
        ///  Returns an enumerator that can iterate through the <c>DataSourceCollection</c>.
        /// </summary>
        /// <returns>An <see cref="Enumerator"/> for the entire <c>DataSourceCollection</c>.</returns>
        public virtual IDataSourceCollectionEnumerator GetEnumerator() {
            return new Enumerator(this);
        }
#endregion

#region Public helpers (just to mimic some nice features of ArrayList)

        /// <summary>
        ///  Gets or sets the number of elements the <c>DataSourceCollection</c> can contain.
        /// </summary>
        public virtual int Capacity
        {
            get {
                return m_array.Length;
            }

            set {
                if (value < m_count)
                    value = m_count;

                if (value != m_array.Length) {
                    if (value > 0) {
                        Sooda.SoodaDataSource[] temp = new Sooda.SoodaDataSource[value];
                        Array.Copy(m_array, temp, m_count);
                        m_array = temp;
                    } else {
                        m_array = new Sooda.SoodaDataSource[DEFAULT_CAPACITY];
                    }
                }
            }
        }

        /// <summary>
        ///  Adds the elements of another <c>DataSourceCollection</c> to the current <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="x">The <c>DataSourceCollection</c> whose elements should be added to the end of the current <c>DataSourceCollection</c>.</param>
        /// <returns>The new <see cref="DataSourceCollection.Count"/> of the <c>DataSourceCollection</c>.</returns>
        public virtual int AddRange(DataSourceCollection x) {
            if (m_count + x.Count >= m_array.Length)
                EnsureCapacity(m_count + x.Count);

            Array.Copy(x.m_array, 0, m_array, m_count, x.Count);
            m_count += x.Count;
            m_version++;

            return m_count;
        }

        /// <summary>
        ///  Adds the elements of a <see cref="Sooda.SoodaDataSource"/> array to the current <c>DataSourceCollection</c>.
        /// </summary>
        /// <param name="x">The <see cref="Sooda.SoodaDataSource"/> array whose elements should be added to the end of the <c>DataSourceCollection</c>.</param>
        /// <returns>The new <see cref="DataSourceCollection.Count"/> of the <c>DataSourceCollection</c>.</returns>
        public virtual int AddRange(Sooda.SoodaDataSource[] x) {
            if (m_count + x.Length >= m_array.Length)
                EnsureCapacity(m_count + x.Length);

            Array.Copy(x, 0, m_array, m_count, x.Length);
            m_count += x.Length;
            m_version++;

            return m_count;
        }

        /// <summary>
        ///  Sets the capacity to the actual number of elements.
        /// </summary>
        public virtual void TrimToSize() {
            this.Capacity = m_count;
        }

#endregion

#region Implementation (helpers)

        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="DataSourceCollection.Count"/>.</para>
        /// </exception>
        private void ValidateIndex(int i) {
            ValidateIndex(i, false);
        }

        /// <exception cref="ArgumentOutOfRangeException">
        ///  <para><paramref name="index"/> is less than zero</para>
        ///  <para>-or-</para>
        ///  <para><paramref name="index"/> is equal to or greater than <see cref="DataSourceCollection.Count"/>.</para>
        /// </exception>
        private void ValidateIndex(int i, bool allowEqualEnd) {
            int max = (allowEqualEnd) ? (m_count) : (m_count - 1);
            if (i < 0 || i > max)
                throw new System.ArgumentOutOfRangeException("Index was out of range.  Must be non-negative and less than the size of the collection.", (object)i, "Specified argument was out of the range of valid values.");
        }

        private void EnsureCapacity(int min) {
            int newCapacity = ((m_array.Length == 0) ? DEFAULT_CAPACITY : m_array.Length * 2);
            if (newCapacity < min)
                newCapacity = min;

            this.Capacity = newCapacity;
        }

#endregion

#region Implementation (ICollection)

        void ICollection.CopyTo(Array array, int start) {
            Array.Copy(m_array, 0, array, start, m_count);
        }

#endregion

#region Implementation (IList)

        object IList.this[int i]
        {
            get {
                return (object)this[i];
            }
            set {
                this[i] = (Sooda.SoodaDataSource)value;
            }
        }

        int IList.Add(object x) {
            return this.Add((Sooda.SoodaDataSource)x);
        }

        bool IList.Contains(object x) {
            return this.Contains((Sooda.SoodaDataSource)x);
        }

        int IList.IndexOf(object x) {
            return this.IndexOf((Sooda.SoodaDataSource)x);
        }

        void IList.Insert(int pos, object x) {
            this.Insert(pos, (Sooda.SoodaDataSource)x);
        }

        void IList.Remove(object x) {
            this.Remove((Sooda.SoodaDataSource)x);
        }

        void IList.RemoveAt(int pos) {
            this.RemoveAt(pos);
        }

#endregion

#region Implementation (IEnumerable)

        IEnumerator IEnumerable.GetEnumerator() {
            return (IEnumerator)(this.GetEnumerator());
        }

#endregion

#region Nested enumerator class
        /// <summary>
        ///  Supports simple iteration over a <see cref="DataSourceCollection"/>.
        /// </summary>
    private class Enumerator : IEnumerator, IDataSourceCollectionEnumerator {
#region Implementation (data)

            private DataSourceCollection m_collection;
            private int m_index;
            private int m_version;

#endregion

#region Construction

            /// <summary>
            ///  Initializes a new instance of the <c>Enumerator</c> class.
            /// </summary>
            /// <param name="tc"></param>
            internal Enumerator(DataSourceCollection tc) {
                m_collection = tc;
                m_index = -1;
                m_version = tc.m_version;
            }

#endregion

#region Operations (type-safe IEnumerator)

            /// <summary>
            ///  Gets the current element in the collection.
            /// </summary>
            public Sooda.SoodaDataSource Current
            {
                get {
                    return m_collection[m_index];
                }
            }

            /// <summary>
            ///  Advances the enumerator to the next element in the collection.
            /// </summary>
            /// <exception cref="InvalidOperationException">
            ///  The collection was modified after the enumerator was created.
            /// </exception>
            /// <returns>
            ///  <c>true</c> if the enumerator was successfully advanced to the next element;
            ///  <c>false</c> if the enumerator has passed the end of the collection.
            /// </returns>
            public bool MoveNext() {
                if (m_version != m_collection.m_version)
                    throw new System.InvalidOperationException("Collection was modified; enumeration operation may not execute.");

                ++m_index;
                return (m_index < m_collection.Count) ? true : false;
            }

            /// <summary>
            ///  Sets the enumerator to its initial position, before the first element in the collection.
            /// </summary>
            public void Reset() {
                m_index = -1;
            }
#endregion

#region Implementation (IEnumerator)

            object IEnumerator.Current
            {
                get {
                    return (object)(this.Current);
                }
            }

#endregion

        }
#endregion

#region Nested Syncronized Wrapper class
    private class SyncDataSourceCollection : DataSourceCollection {
#region Implementation (data)
            private DataSourceCollection m_collection;
            private object m_root;
#endregion

#region Construction

            internal SyncDataSourceCollection(DataSourceCollection list) : base(Tag.Default) {
                m_root = list.SyncRoot;
                m_collection = list;
            }
#endregion

#region Type-safe ICollection
            public override void CopyTo(Sooda.SoodaDataSource[] array) {
                lock (this.m_root)
                    m_collection.CopyTo(array);
            }

            public override void CopyTo(Sooda.SoodaDataSource[] array, int start) {
                lock (this.m_root)
                    m_collection.CopyTo(array, start);
            }
            public override int Count
            {
                get {
                    lock (this.m_root)
                        return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get {
                    return true;
                }
            }

            public override object SyncRoot
            {
                get {
                    return this.m_root;
                }
            }
#endregion

#region Type-safe IList
            public override Sooda.SoodaDataSource this[int i]
            {
                get {
                    lock (this.m_root)
                        return m_collection[i];
                }
                set {
                    lock (this.m_root)
                        m_collection[i] = value;
                }
            }

            public override int Add(Sooda.SoodaDataSource x) {
                lock (this.m_root)
                    return m_collection.Add(x);
            }

            public override void Clear() {
                lock (this.m_root)
                    m_collection.Clear();
            }

            public override bool Contains(Sooda.SoodaDataSource x) {
                lock (this.m_root)
                    return m_collection.Contains(x);
            }

            public override int IndexOf(Sooda.SoodaDataSource x) {
                lock (this.m_root)
                    return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, Sooda.SoodaDataSource x) {
                lock (this.m_root)
                    m_collection.Insert(pos, x);
            }

            public override void Remove(Sooda.SoodaDataSource x) {
                lock (this.m_root)
                    m_collection.Remove(x);
            }

            public override void RemoveAt(int pos) {
                lock (this.m_root)
                    m_collection.RemoveAt(pos);
            }

            public override bool IsFixedSize
            {
                get {
                    return m_collection.IsFixedSize;
                }
            }

            public override bool IsReadOnly
            {
                get {
                    return m_collection.IsReadOnly;
                }
            }
#endregion

#region Type-safe IEnumerable
            public override IDataSourceCollectionEnumerator GetEnumerator() {
                lock (m_root)
                    return m_collection.GetEnumerator();
            }
#endregion

#region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get {
                    lock (this.m_root)
                        return m_collection.Capacity;
                }

                set {
                    lock (this.m_root)
                        m_collection.Capacity = value;
                }
            }

            public override int AddRange(DataSourceCollection x) {
                lock (this.m_root)
                    return m_collection.AddRange(x);
            }

            public override int AddRange(Sooda.SoodaDataSource[] x) {
                lock (this.m_root)
                    return m_collection.AddRange(x);
            }
#endregion

        }
#endregion

#region Nested Read Only Wrapper class
    private class ReadOnlyDataSourceCollection : DataSourceCollection {
#region Implementation (data)
            private DataSourceCollection m_collection;
#endregion

#region Construction

            internal ReadOnlyDataSourceCollection(DataSourceCollection list) : base(Tag.Default) {
                m_collection = list;
            }
#endregion

#region Type-safe ICollection
            public override void CopyTo(Sooda.SoodaDataSource[] array) {
                m_collection.CopyTo(array);
            }

            public override void CopyTo(Sooda.SoodaDataSource[] array, int start) {
                m_collection.CopyTo(array, start);
            }
            public override int Count
            {
                get {
                    return m_collection.Count;
                }
            }

            public override bool IsSynchronized
            {
                get {
                    return m_collection.IsSynchronized;
                }
            }

            public override object SyncRoot
            {
                get {
                    return this.m_collection.SyncRoot;
                }
            }
#endregion

#region Type-safe IList
            public override Sooda.SoodaDataSource this[int i]
            {
                get {
                    return m_collection[i];
                }
                set {
                    throw new NotSupportedException("This is a Read Only Collection and can not be modified");
                }
            }

            public override int Add(Sooda.SoodaDataSource x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Clear() {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool Contains(Sooda.SoodaDataSource x) {
                return m_collection.Contains(x);
            }

            public override int IndexOf(Sooda.SoodaDataSource x) {
                return m_collection.IndexOf(x);
            }

            public override void Insert(int pos, Sooda.SoodaDataSource x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void Remove(Sooda.SoodaDataSource x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override void RemoveAt(int pos) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override bool IsFixedSize
            {
                get {
                    return true;
                }
            }

            public override bool IsReadOnly
            {
                get {
                    return true;
                }
            }
#endregion

#region Type-safe IEnumerable
            public override IDataSourceCollectionEnumerator GetEnumerator() {
                return m_collection.GetEnumerator();
            }
#endregion

#region Public Helpers
            // (just to mimic some nice features of ArrayList)
            public override int Capacity
            {
                get {
                    return m_collection.Capacity;
                }

                set {
                    throw new NotSupportedException("This is a Read Only Collection and can not be modified");
                }
            }

            public override int AddRange(DataSourceCollection x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }

            public override int AddRange(Sooda.SoodaDataSource[] x) {
                throw new NotSupportedException("This is a Read Only Collection and can not be modified");
            }
#endregion

        }
#endregion

    }

}
namespace Sooda {
    public
    class TypeToSoodaObjectFactoryMap : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public TypeToSoodaObjectFactoryMap() {
            innerHash = new Hashtable();
        }
        public TypeToSoodaObjectFactoryMap(TypeToSoodaObjectFactoryMap original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public TypeToSoodaObjectFactoryMap(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public TypeToSoodaObjectFactoryMap(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public TypeToSoodaObjectFactoryMap(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public TypeToSoodaObjectFactoryMap(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public TypeToSoodaObjectFactoryMap(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public TypeToSoodaObjectFactoryMap(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public TypeToSoodaObjectFactoryMap(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public TypeToSoodaObjectFactoryMap(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public TypeToSoodaObjectFactoryMap(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public TypeToSoodaObjectFactoryMapEnumerator GetEnumerator() {
            return new TypeToSoodaObjectFactoryMapEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new TypeToSoodaObjectFactoryMapEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(System.Type key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((System.Type)key);
        }

        public bool Contains(System.Type key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((System.Type)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(System.Type key, ISoodaObjectFactory value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((System.Type)key, (ISoodaObjectFactory)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public ISoodaObjectFactory this[System.Type key]
        {
            get {
                return (ISoodaObjectFactory) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(System.Type)key];
            }
            set {
                this[(System.Type)key] = (ISoodaObjectFactory)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public TypeToSoodaObjectFactoryMap Clone() {
            TypeToSoodaObjectFactoryMap clone = new TypeToSoodaObjectFactoryMap();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (System.Type key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (ISoodaObjectFactory value) {
            return innerHash.ContainsValue(value);
        }
        public static TypeToSoodaObjectFactoryMap Synchronized(TypeToSoodaObjectFactoryMap nonSync) {
            TypeToSoodaObjectFactoryMap sync = new TypeToSoodaObjectFactoryMap();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class TypeToSoodaObjectFactoryMapEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal TypeToSoodaObjectFactoryMapEnumerator (TypeToSoodaObjectFactoryMap enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public System.Type Key
        {
            get {
                return (System.Type)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public ISoodaObjectFactory Value
        {
            get {
                return (ISoodaObjectFactory)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class StringToSoodaObjectFactoryMap : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public StringToSoodaObjectFactoryMap() {
            innerHash = new Hashtable();
        }
        public StringToSoodaObjectFactoryMap(StringToSoodaObjectFactoryMap original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public StringToSoodaObjectFactoryMap(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public StringToSoodaObjectFactoryMap(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public StringToSoodaObjectFactoryMap(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public StringToSoodaObjectFactoryMap(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryMap(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public StringToSoodaObjectFactoryMap(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryMap(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryMap(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryMap(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public StringToSoodaObjectFactoryMapEnumerator GetEnumerator() {
            return new StringToSoodaObjectFactoryMapEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new StringToSoodaObjectFactoryMapEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(string key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((string)key);
        }

        public bool Contains(string key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((string)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(string key, ISoodaObjectFactory value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((string)key, (ISoodaObjectFactory)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public ISoodaObjectFactory this[string key]
        {
            get {
                return (ISoodaObjectFactory) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(string)key];
            }
            set {
                this[(string)key] = (ISoodaObjectFactory)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public StringToSoodaObjectFactoryMap Clone() {
            StringToSoodaObjectFactoryMap clone = new StringToSoodaObjectFactoryMap();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (string key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (ISoodaObjectFactory value) {
            return innerHash.ContainsValue(value);
        }
        public static StringToSoodaObjectFactoryMap Synchronized(StringToSoodaObjectFactoryMap nonSync) {
            StringToSoodaObjectFactoryMap sync = new StringToSoodaObjectFactoryMap();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class StringToSoodaObjectFactoryMapEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal StringToSoodaObjectFactoryMapEnumerator (StringToSoodaObjectFactoryMap enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public string Key
        {
            get {
                return (string)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public ISoodaObjectFactory Value
        {
            get {
                return (ISoodaObjectFactory)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class StringToSoodaObjectMap : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public StringToSoodaObjectMap() {
            innerHash = new Hashtable();
        }
        public StringToSoodaObjectMap(StringToSoodaObjectMap original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public StringToSoodaObjectMap(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public StringToSoodaObjectMap(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public StringToSoodaObjectMap(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public StringToSoodaObjectMap(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public StringToSoodaObjectMap(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public StringToSoodaObjectMap(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public StringToSoodaObjectMap(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public StringToSoodaObjectMap(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public StringToSoodaObjectMap(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public StringToSoodaObjectMapEnumerator GetEnumerator() {
            return new StringToSoodaObjectMapEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new StringToSoodaObjectMapEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(string key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((string)key);
        }

        public bool Contains(string key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((string)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(string key, SoodaObject value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((string)key, (SoodaObject)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public SoodaObject this[string key]
        {
            get {
                return (SoodaObject) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(string)key];
            }
            set {
                this[(string)key] = (SoodaObject)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public StringToSoodaObjectMap Clone() {
            StringToSoodaObjectMap clone = new StringToSoodaObjectMap();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (string key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (SoodaObject value) {
            return innerHash.ContainsValue(value);
        }
        public static StringToSoodaObjectMap Synchronized(StringToSoodaObjectMap nonSync) {
            StringToSoodaObjectMap sync = new StringToSoodaObjectMap();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class StringToSoodaObjectMapEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal StringToSoodaObjectMapEnumerator (StringToSoodaObjectMap enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public string Key
        {
            get {
                return (string)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public SoodaObject Value
        {
            get {
                return (SoodaObject)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class SoodaObjectToStringMap : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public SoodaObjectToStringMap() {
            innerHash = new Hashtable();
        }
        public SoodaObjectToStringMap(SoodaObjectToStringMap original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public SoodaObjectToStringMap(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public SoodaObjectToStringMap(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public SoodaObjectToStringMap(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public SoodaObjectToStringMap(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public SoodaObjectToStringMap(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public SoodaObjectToStringMap(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public SoodaObjectToStringMap(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public SoodaObjectToStringMap(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public SoodaObjectToStringMap(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public SoodaObjectToStringMapEnumerator GetEnumerator() {
            return new SoodaObjectToStringMapEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new SoodaObjectToStringMapEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(SoodaObject key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((SoodaObject)key);
        }

        public bool Contains(SoodaObject key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((SoodaObject)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(SoodaObject key, string value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((SoodaObject)key, (string)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public string this[SoodaObject key]
        {
            get {
                return (string) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(SoodaObject)key];
            }
            set {
                this[(SoodaObject)key] = (string)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public SoodaObjectToStringMap Clone() {
            SoodaObjectToStringMap clone = new SoodaObjectToStringMap();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (SoodaObject key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (string value) {
            return innerHash.ContainsValue(value);
        }
        public static SoodaObjectToStringMap Synchronized(SoodaObjectToStringMap nonSync) {
            SoodaObjectToStringMap sync = new SoodaObjectToStringMap();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class SoodaObjectToStringMapEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal SoodaObjectToStringMapEnumerator (SoodaObjectToStringMap enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public SoodaObject Key
        {
            get {
                return (SoodaObject)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public string Value
        {
            get {
                return (string)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class SoodaObjectToObjectDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public SoodaObjectToObjectDictionary() {
            innerHash = new Hashtable();
        }
        public SoodaObjectToObjectDictionary(SoodaObjectToObjectDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public SoodaObjectToObjectDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public SoodaObjectToObjectDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public SoodaObjectToObjectDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public SoodaObjectToObjectDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public SoodaObjectToObjectDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public SoodaObjectToObjectDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public SoodaObjectToObjectDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public SoodaObjectToObjectDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public SoodaObjectToObjectDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public SoodaObjectToObjectDictionaryEnumerator GetEnumerator() {
            return new SoodaObjectToObjectDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new SoodaObjectToObjectDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(SoodaObject key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((SoodaObject)key);
        }

        public bool Contains(SoodaObject key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((SoodaObject)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(SoodaObject key, object value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((SoodaObject)key, (object)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public object this[SoodaObject key]
        {
            get {
                return (object) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(SoodaObject)key];
            }
            set {
                this[(SoodaObject)key] = (object)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public SoodaObjectToObjectDictionary Clone() {
            SoodaObjectToObjectDictionary clone = new SoodaObjectToObjectDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (SoodaObject key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (object value) {
            return innerHash.ContainsValue(value);
        }
        public static SoodaObjectToObjectDictionary Synchronized(SoodaObjectToObjectDictionary nonSync) {
            SoodaObjectToObjectDictionary sync = new SoodaObjectToObjectDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class SoodaObjectToObjectDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal SoodaObjectToObjectDictionaryEnumerator (SoodaObjectToObjectDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public SoodaObject Key
        {
            get {
                return (SoodaObject)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public object Value
        {
            get {
                return (object)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class StringToSoodaObjectCollectionDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public StringToSoodaObjectCollectionDictionary() {
            innerHash = new Hashtable();
        }
        public StringToSoodaObjectCollectionDictionary(StringToSoodaObjectCollectionDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public StringToSoodaObjectCollectionDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public StringToSoodaObjectCollectionDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public StringToSoodaObjectCollectionDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public StringToSoodaObjectCollectionDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public StringToSoodaObjectCollectionDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public StringToSoodaObjectCollectionDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public StringToSoodaObjectCollectionDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public StringToSoodaObjectCollectionDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public StringToSoodaObjectCollectionDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public StringToSoodaObjectCollectionDictionaryEnumerator GetEnumerator() {
            return new StringToSoodaObjectCollectionDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new StringToSoodaObjectCollectionDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(string key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((string)key);
        }

        public bool Contains(string key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((string)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(string key, SoodaObjectCollection value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((string)key, (SoodaObjectCollection)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public SoodaObjectCollection this[string key]
        {
            get {
                return (SoodaObjectCollection) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(string)key];
            }
            set {
                this[(string)key] = (SoodaObjectCollection)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public StringToSoodaObjectCollectionDictionary Clone() {
            StringToSoodaObjectCollectionDictionary clone = new StringToSoodaObjectCollectionDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (string key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (SoodaObjectCollection value) {
            return innerHash.ContainsValue(value);
        }
        public static StringToSoodaObjectCollectionDictionary Synchronized(StringToSoodaObjectCollectionDictionary nonSync) {
            StringToSoodaObjectCollectionDictionary sync = new StringToSoodaObjectCollectionDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class StringToSoodaObjectCollectionDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal StringToSoodaObjectCollectionDictionaryEnumerator (StringToSoodaObjectCollectionDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public string Key
        {
            get {
                return (string)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public SoodaObjectCollection Value
        {
            get {
                return (SoodaObjectCollection)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class StringToSoodaObjectDictionaryDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public StringToSoodaObjectDictionaryDictionary() {
            innerHash = new Hashtable();
        }
        public StringToSoodaObjectDictionaryDictionary(StringToSoodaObjectDictionaryDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public StringToSoodaObjectDictionaryDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public StringToSoodaObjectDictionaryDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public StringToSoodaObjectDictionaryDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public StringToSoodaObjectDictionaryDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public StringToSoodaObjectDictionaryDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public StringToSoodaObjectDictionaryDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public StringToSoodaObjectDictionaryDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public StringToSoodaObjectDictionaryDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public StringToSoodaObjectDictionaryDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public StringToSoodaObjectDictionaryDictionaryEnumerator GetEnumerator() {
            return new StringToSoodaObjectDictionaryDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new StringToSoodaObjectDictionaryDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(string key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((string)key);
        }

        public bool Contains(string key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((string)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(string key, ObjectToSoodaObjectDictionary value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((string)key, (ObjectToSoodaObjectDictionary)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public ObjectToSoodaObjectDictionary this[string key]
        {
            get {
                return (ObjectToSoodaObjectDictionary) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(string)key];
            }
            set {
                this[(string)key] = (ObjectToSoodaObjectDictionary)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public StringToSoodaObjectDictionaryDictionary Clone() {
            StringToSoodaObjectDictionaryDictionary clone = new StringToSoodaObjectDictionaryDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (string key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (ObjectToSoodaObjectDictionary value) {
            return innerHash.ContainsValue(value);
        }
        public static StringToSoodaObjectDictionaryDictionary Synchronized(StringToSoodaObjectDictionaryDictionary nonSync) {
            StringToSoodaObjectDictionaryDictionary sync = new StringToSoodaObjectDictionaryDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class StringToSoodaObjectDictionaryDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal StringToSoodaObjectDictionaryDictionaryEnumerator (StringToSoodaObjectDictionaryDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public string Key
        {
            get {
                return (string)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public ObjectToSoodaObjectDictionary Value
        {
            get {
                return (ObjectToSoodaObjectDictionary)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class StringToSoodaObjectFactoryDictionaryDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public StringToSoodaObjectFactoryDictionaryDictionary() {
            innerHash = new Hashtable();
        }
        public StringToSoodaObjectFactoryDictionaryDictionary(StringToSoodaObjectFactoryDictionaryDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public StringToSoodaObjectFactoryDictionaryDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public StringToSoodaObjectFactoryDictionaryDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public StringToSoodaObjectFactoryDictionaryDictionaryEnumerator GetEnumerator() {
            return new StringToSoodaObjectFactoryDictionaryDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new StringToSoodaObjectFactoryDictionaryDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(string key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((string)key);
        }

        public bool Contains(string key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((string)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(string key, ObjectToSoodaObjectFactoryDictionary value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((string)key, (ObjectToSoodaObjectFactoryDictionary)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public ObjectToSoodaObjectFactoryDictionary this[string key]
        {
            get {
                return (ObjectToSoodaObjectFactoryDictionary) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(string)key];
            }
            set {
                this[(string)key] = (ObjectToSoodaObjectFactoryDictionary)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public StringToSoodaObjectFactoryDictionaryDictionary Clone() {
            StringToSoodaObjectFactoryDictionaryDictionary clone = new StringToSoodaObjectFactoryDictionaryDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (string key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (ObjectToSoodaObjectFactoryDictionary value) {
            return innerHash.ContainsValue(value);
        }
        public static StringToSoodaObjectFactoryDictionaryDictionary Synchronized(StringToSoodaObjectFactoryDictionaryDictionary nonSync) {
            StringToSoodaObjectFactoryDictionaryDictionary sync = new StringToSoodaObjectFactoryDictionaryDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class StringToSoodaObjectFactoryDictionaryDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal StringToSoodaObjectFactoryDictionaryDictionaryEnumerator (StringToSoodaObjectFactoryDictionaryDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public string Key
        {
            get {
                return (string)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public ObjectToSoodaObjectFactoryDictionary Value
        {
            get {
                return (ObjectToSoodaObjectFactoryDictionary)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class ObjectToSoodaObjectDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public ObjectToSoodaObjectDictionary() {
            innerHash = new Hashtable();
        }
        public ObjectToSoodaObjectDictionary(ObjectToSoodaObjectDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public ObjectToSoodaObjectDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public ObjectToSoodaObjectDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public ObjectToSoodaObjectDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public ObjectToSoodaObjectDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public ObjectToSoodaObjectDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public ObjectToSoodaObjectDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public ObjectToSoodaObjectDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public ObjectToSoodaObjectDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public ObjectToSoodaObjectDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public ObjectToSoodaObjectDictionaryEnumerator GetEnumerator() {
            return new ObjectToSoodaObjectDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new ObjectToSoodaObjectDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(System.Object key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((System.Object)key);
        }

        public bool Contains(System.Object key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((System.Object)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(System.Object key, SoodaObject value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((System.Object)key, (SoodaObject)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public SoodaObject this[System.Object key]
        {
            get {
                return (SoodaObject) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(System.Object)key];
            }
            set {
                this[(System.Object)key] = (SoodaObject)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public ObjectToSoodaObjectDictionary Clone() {
            ObjectToSoodaObjectDictionary clone = new ObjectToSoodaObjectDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (System.Object key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (SoodaObject value) {
            return innerHash.ContainsValue(value);
        }
        public static ObjectToSoodaObjectDictionary Synchronized(ObjectToSoodaObjectDictionary nonSync) {
            ObjectToSoodaObjectDictionary sync = new ObjectToSoodaObjectDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class ObjectToSoodaObjectDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal ObjectToSoodaObjectDictionaryEnumerator (ObjectToSoodaObjectDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public System.Object Key
        {
            get {
                return (System.Object)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public SoodaObject Value
        {
            get {
                return (SoodaObject)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class ObjectToSoodaObjectFactoryDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public ObjectToSoodaObjectFactoryDictionary() {
            innerHash = new Hashtable();
        }
        public ObjectToSoodaObjectFactoryDictionary(ObjectToSoodaObjectFactoryDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public ObjectToSoodaObjectFactoryDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public ObjectToSoodaObjectFactoryDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public ObjectToSoodaObjectFactoryDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public ObjectToSoodaObjectFactoryDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public ObjectToSoodaObjectFactoryDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public ObjectToSoodaObjectFactoryDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public ObjectToSoodaObjectFactoryDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public ObjectToSoodaObjectFactoryDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public ObjectToSoodaObjectFactoryDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public ObjectToSoodaObjectFactoryDictionaryEnumerator GetEnumerator() {
            return new ObjectToSoodaObjectFactoryDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new ObjectToSoodaObjectFactoryDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(System.Object key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((System.Object)key);
        }

        public bool Contains(System.Object key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((System.Object)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(System.Object key, ISoodaObjectFactory value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((System.Object)key, (ISoodaObjectFactory)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public ISoodaObjectFactory this[System.Object key]
        {
            get {
                return (ISoodaObjectFactory) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(System.Object)key];
            }
            set {
                this[(System.Object)key] = (ISoodaObjectFactory)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public ObjectToSoodaObjectFactoryDictionary Clone() {
            ObjectToSoodaObjectFactoryDictionary clone = new ObjectToSoodaObjectFactoryDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (System.Object key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (ISoodaObjectFactory value) {
            return innerHash.ContainsValue(value);
        }
        public static ObjectToSoodaObjectFactoryDictionary Synchronized(ObjectToSoodaObjectFactoryDictionary nonSync) {
            ObjectToSoodaObjectFactoryDictionary sync = new ObjectToSoodaObjectFactoryDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class ObjectToSoodaObjectFactoryDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal ObjectToSoodaObjectFactoryDictionaryEnumerator (ObjectToSoodaObjectFactoryDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public System.Object Key
        {
            get {
                return (System.Object)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public ISoodaObjectFactory Value
        {
            get {
                return (ISoodaObjectFactory)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class IntToSoodaObjectDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public IntToSoodaObjectDictionary() {
            innerHash = new Hashtable();
        }
        public IntToSoodaObjectDictionary(IntToSoodaObjectDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public IntToSoodaObjectDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public IntToSoodaObjectDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public IntToSoodaObjectDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public IntToSoodaObjectDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public IntToSoodaObjectDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public IntToSoodaObjectDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public IntToSoodaObjectDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public IntToSoodaObjectDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public IntToSoodaObjectDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public IntToSoodaObjectDictionaryEnumerator GetEnumerator() {
            return new IntToSoodaObjectDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new IntToSoodaObjectDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(int key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((int)key);
        }

        public bool Contains(int key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((int)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(int key, SoodaObject value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((int)key, (SoodaObject)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public SoodaObject this[int key]
        {
            get {
                return (SoodaObject) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(int)key];
            }
            set {
                this[(int)key] = (SoodaObject)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public IntToSoodaObjectDictionary Clone() {
            IntToSoodaObjectDictionary clone = new IntToSoodaObjectDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (int key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (SoodaObject value) {
            return innerHash.ContainsValue(value);
        }
        public static IntToSoodaObjectDictionary Synchronized(IntToSoodaObjectDictionary nonSync) {
            IntToSoodaObjectDictionary sync = new IntToSoodaObjectDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class IntToSoodaObjectDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal IntToSoodaObjectDictionaryEnumerator (IntToSoodaObjectDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public int Key
        {
            get {
                return (int)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public SoodaObject Value
        {
            get {
                return (SoodaObject)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class SoodaObjectToIntDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public SoodaObjectToIntDictionary() {
            innerHash = new Hashtable();
        }
        public SoodaObjectToIntDictionary(SoodaObjectToIntDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public SoodaObjectToIntDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public SoodaObjectToIntDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public SoodaObjectToIntDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public SoodaObjectToIntDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public SoodaObjectToIntDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public SoodaObjectToIntDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public SoodaObjectToIntDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public SoodaObjectToIntDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public SoodaObjectToIntDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public SoodaObjectToIntDictionaryEnumerator GetEnumerator() {
            return new SoodaObjectToIntDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new SoodaObjectToIntDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(SoodaObject key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((SoodaObject)key);
        }

        public bool Contains(SoodaObject key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((SoodaObject)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(SoodaObject key, int value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((SoodaObject)key, (int)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public int this[SoodaObject key]
        {
            get {
                return (int) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(SoodaObject)key];
            }
            set {
                this[(SoodaObject)key] = (int)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public SoodaObjectToIntDictionary Clone() {
            SoodaObjectToIntDictionary clone = new SoodaObjectToIntDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (SoodaObject key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (int value) {
            return innerHash.ContainsValue(value);
        }
        public static SoodaObjectToIntDictionary Synchronized(SoodaObjectToIntDictionary nonSync) {
            SoodaObjectToIntDictionary sync = new SoodaObjectToIntDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class SoodaObjectToIntDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal SoodaObjectToIntDictionaryEnumerator (SoodaObjectToIntDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public SoodaObject Key
        {
            get {
                return (SoodaObject)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public int Value
        {
            get {
                return (int)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}

namespace Sooda {
    public
    class TypeToSoodaRelationTableDictionary : IDictionary, ICollection, IEnumerable, ICloneable {
        protected Hashtable innerHash;

#region "Constructors"

        public TypeToSoodaRelationTableDictionary() {
            innerHash = new Hashtable();
        }
        public TypeToSoodaRelationTableDictionary(TypeToSoodaRelationTableDictionary original) {
            innerHash = new Hashtable (original.innerHash);
        }
        public TypeToSoodaRelationTableDictionary(IDictionary dictionary) {
            innerHash = new Hashtable (dictionary);
        }

        public TypeToSoodaRelationTableDictionary(int capacity) {
            innerHash = new Hashtable(capacity);
        }

        public TypeToSoodaRelationTableDictionary(IDictionary dictionary, float loadFactor) {
            innerHash = new Hashtable(dictionary, loadFactor);
        }

        public TypeToSoodaRelationTableDictionary(IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (codeProvider, comparer);
        }

        public TypeToSoodaRelationTableDictionary(int capacity, int loadFactor) {
            innerHash = new Hashtable(capacity, loadFactor);
        }

        public TypeToSoodaRelationTableDictionary(IDictionary dictionary, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, codeProvider, comparer);
        }

        public TypeToSoodaRelationTableDictionary(int capacity, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, codeProvider, comparer);
        }

        public TypeToSoodaRelationTableDictionary(IDictionary dictionary, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (dictionary, loadFactor, codeProvider, comparer);
        }

        public TypeToSoodaRelationTableDictionary(int capacity, float loadFactor, IHashCodeProvider codeProvider, IComparer comparer) {
            innerHash = new Hashtable (capacity, loadFactor, codeProvider, comparer);
        }


#endregion

#region Implementation of IDictionary
        public TypeToSoodaRelationTableDictionaryEnumerator GetEnumerator() {
            return new TypeToSoodaRelationTableDictionaryEnumerator(this);
        }

        System.Collections.IDictionaryEnumerator IDictionary.GetEnumerator() {
            return new TypeToSoodaRelationTableDictionaryEnumerator(this);
        }

        IEnumerator IEnumerable.GetEnumerator() {
            return GetEnumerator();
        }

        public void Remove(Type key) {
            innerHash.Remove (key);
        }
        void IDictionary.Remove(object key) {
            Remove ((Type)key);
        }

        public bool Contains(Type key) {
            return innerHash.Contains(key);
        }
        bool IDictionary.Contains(object key) {
            return Contains((Type)key);
        }

        public void Clear() {
            innerHash.Clear();
        }

        public void Add(Type key, Sooda.ObjectMapper.SoodaRelationTable value) {
            innerHash.Add (key, value);
        }
        void IDictionary.Add(object key, object value) {
            Add ((Type)key, (Sooda.ObjectMapper.SoodaRelationTable)value);
        }

        public bool IsReadOnly
        {
            get {
                return innerHash.IsReadOnly;
            }
        }

        public Sooda.ObjectMapper.SoodaRelationTable this[Type key]
        {
            get {
                return (Sooda.ObjectMapper.SoodaRelationTable) innerHash[key];
            }
            set {
                innerHash[key] = value;
            }
        }
        object IDictionary.this[object key]
        {
            get {
                return this[(Type)key];
            }
            set {
                this[(Type)key] = (Sooda.ObjectMapper.SoodaRelationTable)value;
            }
        }

        public System.Collections.ICollection Values
        {
            get {
                return innerHash.Values;
            }
        }

        public System.Collections.ICollection Keys
        {
            get {
                return innerHash.Keys;
            }
        }

        public bool IsFixedSize
        {
            get {
                return innerHash.IsFixedSize;
            }
        }
#endregion

#region Implementation of ICollection
        public void CopyTo(System.Array array, int index) {
            innerHash.CopyTo (array, index);
        }

        public bool IsSynchronized
        {
            get {
                return innerHash.IsSynchronized;
            }
        }

        public int Count
        {
            get {
                return innerHash.Count;
            }
        }

        public object SyncRoot
        {
            get {
                return innerHash.SyncRoot;
            }
        }
#endregion

#region Implementation of ICloneable
        public TypeToSoodaRelationTableDictionary Clone() {
            TypeToSoodaRelationTableDictionary clone = new TypeToSoodaRelationTableDictionary();
            clone.innerHash = (Hashtable) innerHash.Clone();

            return clone;
        }
        object ICloneable.Clone() {
            return Clone();
        }
#endregion

#region "HashTable Methods"
        public bool ContainsKey (Type key) {
            return innerHash.ContainsKey(key);
        }
        public bool ContainsValue (Sooda.ObjectMapper.SoodaRelationTable value) {
            return innerHash.ContainsValue(value);
        }
        public static TypeToSoodaRelationTableDictionary Synchronized(TypeToSoodaRelationTableDictionary nonSync) {
            TypeToSoodaRelationTableDictionary sync = new TypeToSoodaRelationTableDictionary();
            sync.innerHash = Hashtable.Synchronized(nonSync.innerHash);

            return sync;
        }
#endregion

        internal Hashtable InnerHash
        {
            get {
                return innerHash;
            }
        }
    }

    public class TypeToSoodaRelationTableDictionaryEnumerator : IDictionaryEnumerator {
        private IDictionaryEnumerator innerEnumerator;

        internal TypeToSoodaRelationTableDictionaryEnumerator (TypeToSoodaRelationTableDictionary enumerable) {
            innerEnumerator = enumerable.InnerHash.GetEnumerator();
        }

#region Implementation of IDictionaryEnumerator
        public Type Key
        {
            get {
                return (Type)innerEnumerator.Key;
            }
        }
        object IDictionaryEnumerator.Key
        {
            get {
                return Key;
            }
        }


        public Sooda.ObjectMapper.SoodaRelationTable Value
        {
            get {
                return (Sooda.ObjectMapper.SoodaRelationTable)innerEnumerator.Value;
            }
        }
        object IDictionaryEnumerator.Value
        {
            get {
                return Value;
            }
        }

        public System.Collections.DictionaryEntry Entry
        {
            get {
                return innerEnumerator.Entry;
            }
        }

#endregion

#region Implementation of IEnumerator
        public void Reset() {
            innerEnumerator.Reset();
        }

        public bool MoveNext() {
            return innerEnumerator.MoveNext();
        }

        public object Current
        {
            get {
                return innerEnumerator.Current;
            }
        }
#endregion

    }

}
